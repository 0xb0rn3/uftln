#!/usr/bin/env bash
set -euo pipefail

# =====================================================================
#  UFTLN - ULTRA-FAST TERMINAL LINK NETWORK
#  Coded by: 0xbv1
#  Repo: github.com/0xb0rn3/uftln
# =====================================================================

VERSION="0.0.1"
PARALLEL_JOBS=32
CHUNK_SIZE="8M"
BUFFER_SIZE="131072"

# Colors
G="\e[92m"; R="\e[91m"; Y="\e[93m"; B="\e[94m"; M="\e[95m"; C="\e[96m"; N="\e[0m"; BOLD="\e[1m"

# Global vars
PROTOCOL=""
INTERFACE=""
CONNECTION_STRING=""
REMOTE_PATH=""
LOCAL_PATH=""
MODE=""
USERNAME=""
HOST=""
PORT=""
SSH_KEY=""

# =====================================================================
#  SYSTEM OPTIMIZATION
# =====================================================================

optimize_system() {
    echo -e "${M}${BOLD}[TURBO] Optimizing system for MAXIMUM SPEED...${N}"
    
    # TCP/Network optimizations
    sudo sysctl -w net.core.rmem_max=134217728 >/dev/null 2>&1 || true
    sudo sysctl -w net.core.wmem_max=134217728 >/dev/null 2>&1 || true
    sudo sysctl -w net.ipv4.tcp_rmem="4096 87380 134217728" >/dev/null 2>&1 || true
    sudo sysctl -w net.ipv4.tcp_wmem="4096 65536 134217728" >/dev/null 2>&1 || true
    sudo sysctl -w net.ipv4.tcp_window_scaling=1 >/dev/null 2>&1 || true
    sudo sysctl -w net.ipv4.tcp_timestamps=1 >/dev/null 2>&1 || true
    sudo sysctl -w net.ipv4.tcp_sack=1 >/dev/null 2>&1 || true
    sudo sysctl -w net.ipv4.tcp_no_metrics_save=1 >/dev/null 2>&1 || true
    sudo sysctl -w net.core.netdev_max_backlog=250000 >/dev/null 2>&1 || true
    sudo sysctl -w net.ipv4.tcp_congestion_control=bbr >/dev/null 2>&1 || true
    sudo sysctl -w net.core.default_qdisc=fq >/dev/null 2>&1 || true
    sudo sysctl -w net.ipv4.tcp_mtu_probing=1 >/dev/null 2>&1 || true
    
    # File system optimizations
    sudo sysctl -w fs.file-max=2097152 >/dev/null 2>&1 || true
    sudo sysctl -w vm.swappiness=10 >/dev/null 2>&1 || true
    sudo sysctl -w vm.dirty_ratio=40 >/dev/null 2>&1 || true
    sudo sysctl -w vm.dirty_background_ratio=10 >/dev/null 2>&1 || true
    
    ulimit -n 1048576 2>/dev/null || true
    
    echo -e "${G}✓ System turbocharged!${N}"
}

# =====================================================================
#  NETWORK INTERFACE DETECTION
# =====================================================================

detect_interfaces() {
    echo -e "${B}${BOLD}[SCAN] Detecting network interfaces...${N}\n"
    
    mapfile -t IFACES < <(ip -o link show | awk -F': ' '{print $2}' | grep -v "lo")
    
    if [[ ${#IFACES[@]} -eq 0 ]]; then
        echo -e "${R}No network interfaces found!${N}"
        exit 1
    fi
    
    echo -e "${C}Available interfaces:${N}"
    for i in "${!IFACES[@]}"; do
        IFACE="${IFACES[$i]}"
        SPEED=$(ethtool "$IFACE" 2>/dev/null | grep -i speed | awk '{print $2}' || echo "Unknown")
        STATUS=$(ip link show "$IFACE" | grep -o "state [A-Z]*" | awk '{print $2}')
        IP=$(ip -4 addr show "$IFACE" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -1 || echo "No IP")
        
        echo -e "  ${Y}[$((i+1))]${N} ${BOLD}$IFACE${N} - $SPEED - $STATUS - $IP"
    done
    
    echo ""
    read -p "$(echo -e ${Y}Select interface [1-${#IFACES[@]}]: ${N})" IFACE_NUM
    
    if [[ $IFACE_NUM -lt 1 ]] || [[ $IFACE_NUM -gt ${#IFACES[@]} ]]; then
        echo -e "${R}Invalid selection!${N}"
        exit 1
    fi
    
    INTERFACE="${IFACES[$((IFACE_NUM-1))]}"
    echo -e "${G}✓ Using interface: ${BOLD}$INTERFACE${N}\n"
}

# =====================================================================
#  NETWORK DISCOVERY & ARP SCANNING
# =====================================================================

install_scan_tools() {
    local missing=()
    
    command -v nmap >/dev/null 2>&1 || missing+=("nmap")
    command -v arp-scan >/dev/null 2>&1 || missing+=("arp-scan")
    
    if [[ ${#missing[@]} -eq 0 ]]; then
        return 0
    fi
    
    echo -e "${Y}Installing required tools: ${missing[*]}...${N}"
    
    if [[ -f /etc/debian_version ]]; then
        sudo apt-get update -qq >/dev/null 2>&1
        sudo apt-get install -y "${missing[@]}" >/dev/null 2>&1
    elif [[ -f /etc/redhat-release ]]; then
        sudo dnf install -y "${missing[@]}" >/dev/null 2>&1
    elif command -v pacman >/dev/null 2>&1; then
        sudo pacman -Sy --noconfirm "${missing[@]}" >/dev/null 2>&1
    fi
    
    echo -e "${G}✓ Tools installed successfully${N}"
}

scan_network() {
    echo -e "${M}${BOLD}[DISCOVERY] Scanning network for available servers...${N}"
    
    # Get network subnet
    LOCAL_IP=$(ip -4 addr show "$INTERFACE" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -1)
    SUBNET=$(ip -4 addr show "$INTERFACE" | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -1)
    
    if [[ -z "$SUBNET" ]]; then
        echo -e "${R}Could not determine subnet for $INTERFACE${N}"
        return 1
    fi
    
    echo -e "${C}Scanning subnet: ${BOLD}$SUBNET${N}"
    echo -e "${Y}Please wait...${N}\n"
    
    # ARP scan for quick local discovery
    declare -A DISCOVERED_HOSTS
    
    if command -v arp-scan >/dev/null 2>&1; then
        while IFS=$'\t' read -r ip mac vendor; do
            [[ "$ip" == "$LOCAL_IP" ]] && continue
            DISCOVERED_HOSTS["$ip"]="$mac | $vendor"
        done < <(sudo arp-scan --interface="$INTERFACE" --localnet 2>/dev/null | grep -E '^[0-9]+\.' | awk '{print $1"\t"$2"\t"$3" "$4" "$5}')
    fi
    
    # Nmap scan for service detection
    if command -v nmap >/dev/null 2>&1; then
        local temp_file=$(mktemp)
        nmap -p 21,22,990,989 -T4 --open "$SUBNET" -oG "$temp_file" >/dev/null 2>&1
        
        while read -r line; do
            if [[ $line =~ Host:\ ([0-9.]+)\ \(.*Ports:\ (.+) ]]; then
                local ip="${BASH_REMATCH[1]}"
                local ports="${BASH_REMATCH[2]}"
                
                [[ "$ip" == "$LOCAL_IP" ]] && continue
                
                local services=""
                [[ $ports =~ 21/open ]] && services+="FTP "
                [[ $ports =~ 22/open ]] && services+="SSH "
                [[ $ports =~ 990/open ]] && services+="FTPS "
                [[ $ports =~ 989/open ]] && services+="FTPS "
                
                if [[ -n "$services" ]]; then
                    if [[ -n "${DISCOVERED_HOSTS[$ip]:-}" ]]; then
                        DISCOVERED_HOSTS["$ip"]="${DISCOVERED_HOSTS[$ip]} | Services: $services"
                    else
                        DISCOVERED_HOSTS["$ip"]="Unknown MAC | Services: $services"
                    fi
                fi
            fi
        done < "$temp_file"
        rm -f "$temp_file"
    fi
    
    # Display results
    if [[ ${#DISCOVERED_HOSTS[@]} -eq 0 ]]; then
        echo -e "${Y}No servers with FTP/SSH services detected on network${N}\n"
        return 1
    fi
    
    echo -e "${G}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${G}${BOLD}║           DISCOVERED SERVERS ON NETWORK               ║${N}"
    echo -e "${G}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    local -a IP_ARRAY
    local idx=1
    
    for ip in "${!DISCOVERED_HOSTS[@]}"; do
        IP_ARRAY+=("$ip")
        echo -e "  ${Y}[$idx]${N} ${BOLD}$ip${N}"
        echo -e "      ${C}${DISCOVERED_HOSTS[$ip]}${N}"
        echo ""
        ((idx++))
    done
    
    echo -e "${Y}[0]${N} Manually enter server details"
    echo -e "${Y}[R]${N} Rescan network"
    echo ""
    
    read -p "$(echo -e ${Y}Select server [0-${#IP_ARRAY[@]}] or R: ${N})" SERVER_CHOICE
    
    if [[ "$SERVER_CHOICE" =~ ^[Rr]$ ]]; then
        scan_network
        return $?
    elif [[ "$SERVER_CHOICE" == "0" ]]; then
        return 1
    elif [[ $SERVER_CHOICE -ge 1 ]] && [[ $SERVER_CHOICE -le ${#IP_ARRAY[@]} ]]; then
        HOST="${IP_ARRAY[$((SERVER_CHOICE-1))]}"
        echo -e "${G}✓ Selected: ${BOLD}$HOST${N}\n"
        return 0
    else
        echo -e "${R}Invalid selection!${N}"
        return 1
    fi
}

# =====================================================================
#  STEALTHY HOST DETECTION
# =====================================================================

stealthy_ping() {
    local target="$1"
    local spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
    local delay=0.1
    
    # Show scanning animation
    echo -ne "${Y}[⠋] Checking host availability...${N}\r"
    
    # Stealthy ping - single packet, no DNS, low TTL
    local result=0
    if ping -c 1 -W 1 -n -t 32 "$target" >/dev/null 2>&1; then
        result=1
    elif timeout 2 bash -c "exec 3<>/dev/tcp/$target/22" >/dev/null 2>&1; then
        # Fallback: check if SSH port is open
        result=1
    elif timeout 2 bash -c "exec 3<>/dev/tcp/$target/21" >/dev/null 2>&1; then
        # Fallback: check if FTP port is open
        result=1
    fi
    
    # Animate through spinner frames
    local spinchars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
    for i in {0..9}; do
        local char="${spinchars:$i:1}"
        echo -ne "${Y}[$char] Checking host availability...${N}\r"
        sleep $delay
    done
    
    # Clear line and show result
    echo -ne "\r\033[K"
    
    if [[ $result -eq 1 ]]; then
        # Animated green indicator
        for i in {1..3}; do
            echo -ne "${G}[●] $target - Online${N}\r"
            sleep 0.15
            echo -ne "${G}[○] $target - Online${N}\r"
            sleep 0.15
        done
        echo -e "${G}[●] $target - Online${N}"
        return 0
    else
        echo -e "${R}[✗] $target - Offline or unreachable${N}"
        echo -ne "${Y}    Continue anyway? [y/N]: ${N}"
        read -r continue_choice
        [[ "$continue_choice" =~ ^[Yy]$ ]] && return 0 || return 1
    fi
}

select_protocol() {
    echo -e "${M}${BOLD}[PROTOCOL] Select transfer protocol:${N}"
    echo -e "  ${Y}[1]${N} FTP (Fast, unencrypted)"
    echo -e "  ${Y}[2]${N} FTPS (FTP over SSL/TLS)"
    echo -e "  ${Y}[3]${N} SFTP (SSH File Transfer - RECOMMENDED)"
    echo -e "  ${Y}[4]${N} SCP (Secure Copy - Ultra fast)"
    echo ""
    read -p "$(echo -e ${Y}Choice [1-4]: ${N})" PROTO_CHOICE
    
    case $PROTO_CHOICE in
        1) PROTOCOL="ftp" ;;
        2) PROTOCOL="ftps" ;;
        3) PROTOCOL="sftp" ;;
        4) PROTOCOL="scp" ;;
        *) echo -e "${R}Invalid choice!${N}"; exit 1 ;;
    esac
    
    echo -e "${G}✓ Protocol: ${BOLD}${PROTOCOL^^}${N}\n"
}

# =====================================================================
#  CONNECTION SETUP
# =====================================================================

setup_connection() {
    echo -e "${C}${BOLD}[CONNECT] Connection setup${N}\n"
    
    echo -e "${Y}Would you like to scan the network for available servers?${N}"
    read -p "$(echo -e ${Y}[Y/n]: ${N})" SCAN_CHOICE
    
    if [[ ! "$SCAN_CHOICE" =~ ^[Nn]$ ]]; then
        install_scan_tools
        if scan_network; then
            # HOST was set by scan_network
            :
        else
            # Manual entry
            read -p "$(echo -e ${Y}Host: ${N})" HOST
            if ! stealthy_ping "$HOST"; then
                echo -e "${R}Aborting connection setup.${N}"
                exit 1
            fi
        fi
    else
        read -p "$(echo -e ${Y}Host: ${N})" HOST
        if ! stealthy_ping "$HOST"; then
            echo -e "${R}Aborting connection setup.${N}"
            exit 1
        fi
    fi
    
    read -p "$(echo -e ${Y}Username: ${N})" USERNAME
    read -p "$(echo -e ${Y}Port [default 21/22]: ${N})" PORT
    
    if [[ -z "$PORT" ]]; then
        [[ "$PROTOCOL" == "ftp" || "$PROTOCOL" == "ftps" ]] && PORT=21 || PORT=22
    fi
    
    if [[ "$PROTOCOL" == "sftp" || "$PROTOCOL" == "scp" ]]; then
        read -p "$(echo -e ${Y}SSH key path [press Enter for password]: ${N})" SSH_KEY
    fi
    
    CONNECTION_STRING="$USERNAME@$HOST:$PORT"
    echo -e "${G}✓ Connection: ${BOLD}$CONNECTION_STRING${N}\n"
}

# =====================================================================
#  MODE SELECTION
# =====================================================================

select_mode() {
    echo -e "${M}${BOLD}[MODE] Select operation:${N}"
    echo -e "  ${Y}[1]${N} Upload (Local → Remote)"
    echo -e "  ${Y}[2]${N} Download (Remote → Local)"
    echo -e "  ${Y}[3]${N} Sync (Bidirectional)"
    echo -e "  ${Y}[4]${N} Mass Upload (Multiple files/folders)"
    echo -e "  ${Y}[5]${N} Mass Download (Multiple remote paths)"
    echo ""
    read -p "$(echo -e ${Y}Choice [1-5]: ${N})" MODE_CHOICE
    
    case $MODE_CHOICE in
        1) MODE="upload" ;;
        2) MODE="download" ;;
        3) MODE="sync" ;;
        4) MODE="mass_upload" ;;
        5) MODE="mass_download" ;;
        *) echo -e "${R}Invalid choice!${N}"; exit 1 ;;
    esac
    
    echo -e "${G}✓ Mode: ${BOLD}${MODE^^}${N}\n"
}

# =====================================================================
#  PATH SETUP
# =====================================================================

setup_paths() {
    if [[ "$MODE" == "upload" || "$MODE" == "sync" ]]; then
        read -p "$(echo -e ${Y}Local path to transfer: ${N})" LOCAL_PATH
        if [[ ! -e "$LOCAL_PATH" ]]; then
            echo -e "${R}Path doesn't exist!${N}"
            exit 1
        fi
    fi
    
    if [[ "$MODE" == "mass_upload" ]]; then
        echo -e "${C}Enter local paths to upload (one per line, empty line to finish):${N}"
        LOCAL_PATHS=()
        while true; do
            read -p "$(echo -e ${Y}Path $((${#LOCAL_PATHS[@]}+1)): ${N})" path
            [[ -z "$path" ]] && break
            if [[ ! -e "$path" ]]; then
                echo -e "${R}Path doesn't exist! Skipping...${N}"
                continue
            fi
            LOCAL_PATHS+=("$path")
            echo -e "${G}✓ Added: $path${N}"
        done
        
        if [[ ${#LOCAL_PATHS[@]} -eq 0 ]]; then
            echo -e "${R}No valid paths provided!${N}"
            exit 1
        fi
        echo -e "${C}Total paths: ${BOLD}${#LOCAL_PATHS[@]}${N}\n"
    fi
    
    if [[ "$MODE" == "mass_download" ]]; then
        echo -e "${C}Enter remote paths to download (one per line, empty line to finish):${N}"
        REMOTE_PATHS=()
        while true; do
            read -p "$(echo -e ${Y}Remote path $((${#REMOTE_PATHS[@]}+1)): ${N})" path
            [[ -z "$path" ]] && break
            REMOTE_PATHS+=("$path")
            echo -e "${G}✓ Added: $path${N}"
        done
        
        if [[ ${#REMOTE_PATHS[@]} -eq 0 ]]; then
            echo -e "${R}No valid paths provided!${N}"
            exit 1
        fi
        echo -e "${C}Total paths: ${BOLD}${#REMOTE_PATHS[@]}${N}\n"
    fi
    
    if [[ "$MODE" == "download" || "$MODE" == "sync" ]]; then
        read -p "$(echo -e ${Y}Remote path to transfer: ${N})" REMOTE_PATH
    fi
    
    if [[ "$MODE" == "upload" ]]; then
        read -p "$(echo -e ${Y}Remote destination [default /]: ${N})" REMOTE_PATH
        [[ -z "$REMOTE_PATH" ]] && REMOTE_PATH="/"
    fi
    
    if [[ "$MODE" == "download" ]]; then
        read -p "$(echo -e ${Y}Local destination [default ./downloads]: ${N})" LOCAL_PATH
        [[ -z "$LOCAL_PATH" ]] && LOCAL_PATH="./downloads"
        mkdir -p "$LOCAL_PATH"
    fi
    
    if [[ "$MODE" == "mass_upload" ]]; then
        read -p "$(echo -e ${Y}Remote destination directory [default /]: ${N})" REMOTE_PATH
        [[ -z "$REMOTE_PATH" ]] && REMOTE_PATH="/"
    fi
    
    if [[ "$MODE" == "mass_download" ]]; then
        read -p "$(echo -e ${Y}Local destination directory [default ./downloads]: ${N})" LOCAL_PATH
        [[ -z "$LOCAL_PATH" ]] && LOCAL_PATH="./downloads"
        mkdir -p "$LOCAL_PATH"
    fi
}

# =====================================================================
#  ULTRA-FAST TRANSFERS
# =====================================================================

ultra_sftp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating ULTRA-FAST SFTP...${N}\n"
    
    SSH_OPTS="-o Compression=no -o Ciphers=aes128-gcm@openssh.com,aes256-gcm@openssh.com -o MACs=umac-128@openssh.com"
    [[ -n "${SSH_KEY:-}" ]] && SSH_OPTS="$SSH_OPTS -i $SSH_KEY"
    
    if [[ "$MODE" == "upload" ]]; then
        if [[ -d "$LOCAL_PATH" ]]; then
            echo -e "${G}[BEAST MODE] Parallel directory upload...${N}"
            rsync -avz --progress --stats \
                -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
                --bwlimit=0 \
                --partial --partial-dir=.rsync-partial \
                --inplace \
                "$LOCAL_PATH/" "$USERNAME@$HOST:$REMOTE_PATH"
        else
            scp -P "$PORT" $SSH_OPTS -o TCPRcvBufPoll=yes \
                -o TCPRcvBuf=$BUFFER_SIZE \
                "$LOCAL_PATH" "$USERNAME@$HOST:$REMOTE_PATH"
        fi
    elif [[ "$MODE" == "download" ]]; then
        echo -e "${G}[BEAST MODE] Parallel download...${N}"
        rsync -avz --progress --stats \
            -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
            --bwlimit=0 \
            --partial --partial-dir=.rsync-partial \
            --inplace \
            "$USERNAME@$HOST:$REMOTE_PATH" "$LOCAL_PATH/"
    elif [[ "$MODE" == "sync" ]]; then
        echo -e "${G}[SYNC MODE] Bidirectional sync...${N}"
        rsync -avz --progress --stats \
            -e "ssh -p $PORT $SSH_OPTS" \
            --delete \
            "$LOCAL_PATH/" "$USERNAME@$HOST:$REMOTE_PATH"
    elif [[ "$MODE" == "mass_upload" ]]; then
        echo -e "${G}[MASS UPLOAD] Transferring ${#LOCAL_PATHS[@]} items...${N}\n"
        local completed=0
        local failed=0
        
        for path in "${LOCAL_PATHS[@]}"; do
            local basename=$(basename "$path")
            echo -e "${C}[${G}$((completed+1))${C}/${#LOCAL_PATHS[@]}] Uploading: ${BOLD}$basename${N}"
            
            if [[ -d "$path" ]]; then
                if rsync -avz --progress \
                    -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
                    --bwlimit=0 \
                    --partial --partial-dir=.rsync-partial \
                    --inplace \
                    "$path/" "$USERNAME@$HOST:$REMOTE_PATH/$basename/" 2>/dev/null; then
                    echo -e "${G}✓ Completed: $basename${N}\n"
                    ((completed++))
                else
                    echo -e "${R}✗ Failed: $basename${N}\n"
                    ((failed++))
                fi
            else
                if scp -P "$PORT" $SSH_OPTS "$path" "$USERNAME@$HOST:$REMOTE_PATH/" 2>/dev/null; then
                    echo -e "${G}✓ Completed: $basename${N}\n"
                    ((completed++))
                else
                    echo -e "${R}✗ Failed: $basename${N}\n"
                    ((failed++))
                fi
            fi
        done
        
        echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
    elif [[ "$MODE" == "mass_download" ]]; then
        echo -e "${G}[MASS DOWNLOAD] Transferring ${#REMOTE_PATHS[@]} items...${N}\n"
        local completed=0
        local failed=0
        
        for path in "${REMOTE_PATHS[@]}"; do
            local basename=$(basename "$path")
            echo -e "${C}[${G}$((completed+1))${C}/${#REMOTE_PATHS[@]}] Downloading: ${BOLD}$basename${N}"
            
            if rsync -avz --progress \
                -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
                --bwlimit=0 \
                --partial --partial-dir=.rsync-partial \
                --inplace \
                "$USERNAME@$HOST:$path" "$LOCAL_PATH/" 2>/dev/null; then
                echo -e "${G}✓ Completed: $basename${N}\n"
                ((completed++))
            else
                echo -e "${R}✗ Failed: $basename${N}\n"
                ((failed++))
            fi
        done
        
        echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
    fi
}

ultra_scp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating ULTRA-FAST SCP...${N}\n"
    
    SSH_OPTS="-o Compression=no -c aes128-gcm@openssh.com -o MACs=umac-128@openssh.com"
    [[ -n "${SSH_KEY:-}" ]] && SSH_OPTS="$SSH_OPTS -i $SSH_KEY"
    
    if [[ "$MODE" == "upload" ]]; then
        scp -P "$PORT" $SSH_OPTS -r "$LOCAL_PATH" "$USERNAME@$HOST:$REMOTE_PATH"
    elif [[ "$MODE" == "download" ]]; then
        scp -P "$PORT" $SSH_OPTS -r "$USERNAME@$HOST:$REMOTE_PATH" "$LOCAL_PATH"
    elif [[ "$MODE" == "mass_upload" ]]; then
        echo -e "${G}[MASS UPLOAD] Transferring ${#LOCAL_PATHS[@]} items...${N}\n"
        local completed=0
        local failed=0
        
        for path in "${LOCAL_PATHS[@]}"; do
            local basename=$(basename "$path")
            echo -e "${C}[${G}$((completed+1))${C}/${#LOCAL_PATHS[@]}] Uploading: ${BOLD}$basename${N}"
            
            if scp -P "$PORT" $SSH_OPTS -r "$path" "$USERNAME@$HOST:$REMOTE_PATH/" 2>/dev/null; then
                echo -e "${G}✓ Completed: $basename${N}\n"
                ((completed++))
            else
                echo -e "${R}✗ Failed: $basename${N}\n"
                ((failed++))
            fi
        done
        
        echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
    elif [[ "$MODE" == "mass_download" ]]; then
        echo -e "${G}[MASS DOWNLOAD] Transferring ${#REMOTE_PATHS[@]} items...${N}\n"
        local completed=0
        local failed=0
        
        for path in "${REMOTE_PATHS[@]}"; do
            local basename=$(basename "$path")
            echo -e "${C}[${G}$((completed+1))${C}/${#REMOTE_PATHS[@]}] Downloading: ${BOLD}$basename${N}"
            
            if scp -P "$PORT" $SSH_OPTS -r "$USERNAME@$HOST:$path" "$LOCAL_PATH/" 2>/dev/null; then
                echo -e "${G}✓ Completed: $basename${N}\n"
                ((completed++))
            else
                echo -e "${R}✗ Failed: $basename${N}\n"
                ((failed++))
            fi
        done
        
        echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
    fi
}

ultra_ftp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating FTP transfer...${N}\n"
    
    if command -v lftp >/dev/null 2>&1; then
        LFTP_CMD="lftp -u $USERNAME -p $PORT"
        [[ "$PROTOCOL" == "ftps" ]] && LFTP_CMD="$LFTP_CMD -e 'set ftp:ssl-force true'"
        
        if [[ "$MODE" == "upload" ]]; then
            $LFTP_CMD <<EOF
open $HOST
mirror -R --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$LOCAL_PATH" "$REMOTE_PATH"
bye
EOF
        elif [[ "$MODE" == "download" ]]; then
            $LFTP_CMD <<EOF
open $HOST
mirror --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$REMOTE_PATH" "$LOCAL_PATH"
bye
EOF
        elif [[ "$MODE" == "mass_upload" ]]; then
            echo -e "${G}[MASS UPLOAD] Transferring ${#LOCAL_PATHS[@]} items...${N}\n"
            local completed=0
            local failed=0
            
            for path in "${LOCAL_PATHS[@]}"; do
                local basename=$(basename "$path")
                echo -e "${C}[${G}$((completed+1))${C}/${#LOCAL_PATHS[@]}] Uploading: ${BOLD}$basename${N}"
                
                if $LFTP_CMD <<EOF
open $HOST
mirror -R --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$path" "$REMOTE_PATH/$basename"
bye
EOF
                then
                    echo -e "${G}✓ Completed: $basename${N}\n"
                    ((completed++))
                else
                    echo -e "${R}✗ Failed: $basename${N}\n"
                    ((failed++))
                fi
            done
            
            echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
        elif [[ "$MODE" == "mass_download" ]]; then
            echo -e "${G}[MASS DOWNLOAD] Transferring ${#REMOTE_PATHS[@]} items...${N}\n"
            local completed=0
            local failed=0
            
            for path in "${REMOTE_PATHS[@]}"; do
                local basename=$(basename "$path")
                echo -e "${C}[${G}$((completed+1))${C}/${#REMOTE_PATHS[@]}] Downloading: ${BOLD}$basename${N}"
                
                if $LFTP_CMD <<EOF
open $HOST
mirror --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$path" "$LOCAL_PATH/$basename"
bye
EOF
                then
                    echo -e "${G}✓ Completed: $basename${N}\n"
                    ((completed++))
                else
                    echo -e "${R}✗ Failed: $basename${N}\n"
                    ((failed++))
                fi
            done
            
            echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
        fi
    else
        echo -e "${Y}Installing lftp for maximum FTP performance...${N}"
        sudo apt-get install -y lftp 2>/dev/null || sudo dnf install -y lftp 2>/dev/null || sudo pacman -S --noconfirm lftp
        ultra_ftp_transfer
    fi
}

# =====================================================================
#  BANDWIDTH MONITOR
# =====================================================================

monitor_bandwidth() {
    echo -e "${C}${BOLD}[MONITOR] Real-time bandwidth (Ctrl+C to stop)${N}\n"
    
    if command -v iftop >/dev/null 2>&1; then
        sudo iftop -i "$INTERFACE" -t -s 1
    elif command -v nload >/dev/null 2>&1; then
        nload "$INTERFACE"
    else
        while true; do
            if [ ! -d /sys/class/net/"$INTERFACE" ]; then
                echo "Error: Network interface '$INTERFACE' not found."
                break
            fi
            
            RX1=$(cat /sys/class/net/"$INTERFACE"/statistics/rx_bytes)
            TX1=$(cat /sys/class/net/"$INTERFACE"/statistics/tx_bytes)
            sleep 1
            RX2=$(cat /sys/class/net/"$INTERFACE"/statistics/rx_bytes)
            TX2=$(cat /sys/class/net/"$INTERFACE"/statistics/tx_bytes)
            
            RXRATE=$(( (RX2 - RX1) / 1024 / 1024 ))
            TXRATE=$(( (TX2 - TX1) / 1024 / 1024 ))
            
            echo -e "${G}↓ ${RXRATE} MB/s ${R}↑ ${TXRATE} MB/s${N}"
        done
    fi
}

# =====================================================================
#  MAIN EXECUTION
# =====================================================================

show_banner() {
    echo -e "${M}${BOLD}"
    echo "╔═══════════════════════════════════════════════════════╗"
    echo "║              UFTLN v$VERSION - by 0xbv1                   ║"
    echo "║        ULTRA-FAST TERMINAL LINK NETWORK               ║"
    echo "║       github.com/0xb0rn3/uftln                        ║"
    echo "╚═══════════════════════════════════════════════════════╝"
    echo -e "${N}\n"
}

main() {
    show_banner
    optimize_system
    detect_interfaces
    select_protocol
    setup_connection
    select_mode
    setup_paths
    
    echo -e "${M}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${M}${BOLD}║                 TRANSFER STARTING...                  ║${N}"
    echo -e "${M}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    START_TIME=$(date +%s)
    
    case $PROTOCOL in
        sftp) ultra_sftp_transfer ;;
        scp) ultra_scp_transfer ;;
        ftp|ftps) ultra_ftp_transfer ;;
    esac
    
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))
    
    echo -e "\n${G}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${G}${BOLD}║              TRANSFER COMPLETE!                       ║${N}"
    echo -e "${G}${BOLD}║              Duration: ${DURATION}s                          ║${N}"
    echo -e "${G}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    read -p "$(echo -e ${Y}Monitor bandwidth? [y/N]: ${N})" MONITOR
    [[ "$MONITOR" =~ ^[Yy]$ ]] && monitor_bandwidth
}

# Check if running as script
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
\t' read -r ip mac vendor; do
            [[ "$ip" == "$LOCAL_IP" ]] && continue
            DISCOVERED_HOSTS["$ip"]="$mac | $vendor"
        done < <(sudo arp-scan --interface="$INTERFACE" --localnet 2>/dev/null | grep -E '^[0-9]+\.' | awk '{print $1"\t"$2"\t"$3" "$4" "$5}')
    fi
    
    # Nmap scan for service detection
    if command -v nmap >/dev/null 2>&1; then
        local temp_file=$(mktemp)
        nmap -p 21,22,990,989 -T4 --open "$SUBNET" -oG "$temp_file" >/dev/null 2>&1
        
        while read -r line; do
            if [[ $line =~ Host:\ ([0-9.]+)\ \(.*Ports:\ (.+) ]]; then
                local ip="${BASH_REMATCH[1]}"
                local ports="${BASH_REMATCH[2]}"
                
                [[ "$ip" == "$LOCAL_IP" ]] && continue
                
                local services=""
                [[ $ports =~ 21/open ]] && services+="FTP "
                [[ $ports =~ 22/open ]] && services+="SSH "
                [[ $ports =~ 990/open ]] && services+="FTPS "
                [[ $ports =~ 989/open ]] && services+="FTPS "
                
                if [[ -n "$services" ]]; then
                    if [[ -n "${DISCOVERED_HOSTS[$ip]:-}" ]]; then
                        DISCOVERED_HOSTS["$ip"]="${DISCOVERED_HOSTS[$ip]} | Services: $services"
                    else
                        DISCOVERED_HOSTS["$ip"]="Unknown MAC | Services: $services"
                    fi
                fi
            fi
        done < "$temp_file"
        rm -f "$temp_file"
    fi
    
    # Display results
    if [[ ${#DISCOVERED_HOSTS[@]} -eq 0 ]]; then
        echo -e "${Y}No servers with FTP/SSH services detected on network${N}\n"
        return 1
    fi
    
    echo -e "${G}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${G}${BOLD}║           DISCOVERED SERVERS ON NETWORK               ║${N}"
    echo -e "${G}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    local -a IP_ARRAY
    local idx=1
    
    for ip in "${!DISCOVERED_HOSTS[@]}"; do
        IP_ARRAY+=("$ip")
        echo -e "  ${Y}[$idx]${N} ${BOLD}$ip${N}"
        echo -e "      ${C}${DISCOVERED_HOSTS[$ip]}${N}"
        echo ""
        ((idx++))
    done
    
    echo -e "${Y}[0]${N} Manually enter server details"
    echo -e "${Y}[R]${N} Rescan network"
    echo ""
    
    read -p "$(echo -e ${Y}Select server [0-${#IP_ARRAY[@]}] or R: ${N})" SERVER_CHOICE
    
    if [[ "$SERVER_CHOICE" =~ ^[Rr]$ ]]; then
        scan_network
        return $?
    elif [[ "$SERVER_CHOICE" == "0" ]]; then
        return 1
    elif [[ $SERVER_CHOICE -ge 1 ]] && [[ $SERVER_CHOICE -le ${#IP_ARRAY[@]} ]]; then
        HOST="${IP_ARRAY[$((SERVER_CHOICE-1))]}"
        echo -e "${G}✓ Selected: ${BOLD}$HOST${N}\n"
        return 0
    else
        echo -e "${R}Invalid selection!${N}"
        return 1
    fi
}

# =====================================================================
#  PROTOCOL SELECTION
# =====================================================================

select_protocol() {
    echo -e "${M}${BOLD}[PROTOCOL] Select transfer protocol:${N}"
    echo -e "  ${Y}[1]${N} FTP (Fast, unencrypted)"
    echo -e "  ${Y}[2]${N} FTPS (FTP over SSL/TLS)"
    echo -e "  ${Y}[3]${N} SFTP (SSH File Transfer - RECOMMENDED)"
    echo -e "  ${Y}[4]${N} SCP (Secure Copy - Ultra fast)"
    echo ""
    read -p "$(echo -e ${Y}Choice [1-4]: ${N})" PROTO_CHOICE
    
    case $PROTO_CHOICE in
        1) PROTOCOL="ftp" ;;
        2) PROTOCOL="ftps" ;;
        3) PROTOCOL="sftp" ;;
        4) PROTOCOL="scp" ;;
        *) echo -e "${R}Invalid choice!${N}"; exit 1 ;;
    esac
    
    echo -e "${G}✓ Protocol: ${BOLD}${PROTOCOL^^}${N}\n"
}

# =====================================================================
#  CONNECTION SETUP
# =====================================================================

setup_connection() {
    echo -e "${C}${BOLD}[CONNECT] Connection setup${N}\n"
    
    echo -e "${Y}Would you like to scan the network for available servers?${N}"
    read -p "$(echo -e ${Y}[Y/n]: ${N})" SCAN_CHOICE
    
    if [[ ! "$SCAN_CHOICE" =~ ^[Nn]$ ]]; then
        install_scan_tools
        if scan_network; then
            # HOST was set by scan_network
            :
        else
            # Manual entry
            read -p "$(echo -e ${Y}Host: ${N})" HOST
        fi
    else
        read -p "$(echo -e ${Y}Host: ${N})" HOST
    fi
    
    read -p "$(echo -e ${Y}Username: ${N})" USERNAME
    read -p "$(echo -e ${Y}Port [default 21/22]: ${N})" PORT
    
    if [[ -z "$PORT" ]]; then
        [[ "$PROTOCOL" == "ftp" || "$PROTOCOL" == "ftps" ]] && PORT=21 || PORT=22
    fi
    
    if [[ "$PROTOCOL" == "sftp" || "$PROTOCOL" == "scp" ]]; then
        read -p "$(echo -e ${Y}SSH key path [press Enter for password]: ${N})" SSH_KEY
    fi
    
    CONNECTION_STRING="$USERNAME@$HOST:$PORT"
    echo -e "${G}✓ Connection: ${BOLD}$CONNECTION_STRING${N}\n"
}

# =====================================================================
#  MODE SELECTION
# =====================================================================

select_mode() {
    echo -e "${M}${BOLD}[MODE] Select operation:${N}"
    echo -e "  ${Y}[1]${N} Upload (Local → Remote)"
    echo -e "  ${Y}[2]${N} Download (Remote → Local)"
    echo -e "  ${Y}[3]${N} Sync (Bidirectional)"
    echo ""
    read -p "$(echo -e ${Y}Choice [1-3]: ${N})" MODE_CHOICE
    
    case $MODE_CHOICE in
        1) MODE="upload" ;;
        2) MODE="download" ;;
        3) MODE="sync" ;;
        *) echo -e "${R}Invalid choice!${N}"; exit 1 ;;
    esac
    
    echo -e "${G}✓ Mode: ${BOLD}${MODE^^}${N}\n"
}

# =====================================================================
#  PATH SETUP
# =====================================================================

setup_paths() {
    if [[ "$MODE" == "upload" || "$MODE" == "sync" ]]; then
        read -p "$(echo -e ${Y}Local path to transfer: ${N})" LOCAL_PATH
        if [[ ! -e "$LOCAL_PATH" ]]; then
            echo -e "${R}Path doesn't exist!${N}"
            exit 1
        fi
    fi
    
    if [[ "$MODE" == "download" || "$MODE" == "sync" ]]; then
        read -p "$(echo -e ${Y}Remote path to transfer: ${N})" REMOTE_PATH
    fi
    
    if [[ "$MODE" == "upload" ]]; then
        read -p "$(echo -e ${Y}Remote destination [default /]: ${N})" REMOTE_PATH
        [[ -z "$REMOTE_PATH" ]] && REMOTE_PATH="/"
    fi
    
    if [[ "$MODE" == "download" ]]; then
        read -p "$(echo -e ${Y}Local destination [default ./downloads]: ${N})" LOCAL_PATH
        [[ -z "$LOCAL_PATH" ]] && LOCAL_PATH="./downloads"
        mkdir -p "$LOCAL_PATH"
    fi
}

# =====================================================================
#  ULTRA-FAST TRANSFERS
# =====================================================================

ultra_sftp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating ULTRA-FAST SFTP...${N}\n"
    
    SSH_OPTS="-o Compression=no -o Ciphers=aes128-gcm@openssh.com,aes256-gcm@openssh.com -o MACs=umac-128@openssh.com"
    [[ -n "${SSH_KEY:-}" ]] && SSH_OPTS="$SSH_OPTS -i $SSH_KEY"
    
    if [[ "$MODE" == "upload" ]]; then
        if [[ -d "$LOCAL_PATH" ]]; then
            echo -e "${G}[BEAST MODE] Parallel directory upload...${N}"
            rsync -avz --progress --stats \
                -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
                --bwlimit=0 \
                --partial --partial-dir=.rsync-partial \
                --inplace \
                "$LOCAL_PATH/" "$USERNAME@$HOST:$REMOTE_PATH"
        else
            scp -P "$PORT" $SSH_OPTS -o TCPRcvBufPoll=yes \
                -o TCPRcvBuf=$BUFFER_SIZE \
                "$LOCAL_PATH" "$USERNAME@$HOST:$REMOTE_PATH"
        fi
    elif [[ "$MODE" == "download" ]]; then
        echo -e "${G}[BEAST MODE] Parallel download...${N}"
        rsync -avz --progress --stats \
            -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
            --bwlimit=0 \
            --partial --partial-dir=.rsync-partial \
            --inplace \
            "$USERNAME@$HOST:$REMOTE_PATH" "$LOCAL_PATH/"
    else
        echo -e "${G}[SYNC MODE] Bidirectional sync...${N}"
        rsync -avz --progress --stats \
            -e "ssh -p $PORT $SSH_OPTS" \
            --delete \
            "$LOCAL_PATH/" "$USERNAME@$HOST:$REMOTE_PATH"
    fi
}

ultra_scp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating ULTRA-FAST SCP...${N}\n"
    
    SSH_OPTS="-o Compression=no -c aes128-gcm@openssh.com -o MACs=umac-128@openssh.com"
    [[ -n "${SSH_KEY:-}" ]] && SSH_OPTS="$SSH_OPTS -i $SSH_KEY"
    
    if [[ "$MODE" == "upload" ]]; then
        scp -P "$PORT" $SSH_OPTS -r "$LOCAL_PATH" "$USERNAME@$HOST:$REMOTE_PATH"
    else
        scp -P "$PORT" $SSH_OPTS -r "$USERNAME@$HOST:$REMOTE_PATH" "$LOCAL_PATH"
    fi
}

ultra_ftp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating FTP transfer...${N}\n"
    
    if command -v lftp >/dev/null 2>&1; then
        LFTP_CMD="lftp -u $USERNAME -p $PORT"
        [[ "$PROTOCOL" == "ftps" ]] && LFTP_CMD="$LFTP_CMD -e 'set ftp:ssl-force true'"
        
        if [[ "$MODE" == "upload" ]]; then
            $LFTP_CMD <<EOF
open $HOST
mirror -R --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$LOCAL_PATH" "$REMOTE_PATH"
bye
EOF
        else
            $LFTP_CMD <<EOF
open $HOST
mirror --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$REMOTE_PATH" "$LOCAL_PATH"
bye
EOF
        fi
    else
        echo -e "${Y}Installing lftp for maximum FTP performance...${N}"
        sudo apt-get install -y lftp 2>/dev/null || sudo dnf install -y lftp 2>/dev/null || sudo pacman -S --noconfirm lftp
        ultra_ftp_transfer
    fi
}

# =====================================================================
#  BANDWIDTH MONITOR
# =====================================================================

monitor_bandwidth() {
    echo -e "${C}${BOLD}[MONITOR] Real-time bandwidth (Ctrl+C to stop)${N}\n"
    
    if command -v iftop >/dev/null 2>&1; then
        sudo iftop -i "$INTERFACE" -t -s 1
    elif command -v nload >/dev/null 2>&1; then
        nload "$INTERFACE"
    else
        while true; do
            if [ ! -d /sys/class/net/"$INTERFACE" ]; then
                echo "Error: Network interface '$INTERFACE' not found."
                break
            fi
            
            RX1=$(cat /sys/class/net/"$INTERFACE"/statistics/rx_bytes)
            TX1=$(cat /sys/class/net/"$INTERFACE"/statistics/tx_bytes)
            sleep 1
            RX2=$(cat /sys/class/net/"$INTERFACE"/statistics/rx_bytes)
            TX2=$(cat /sys/class/net/"$INTERFACE"/statistics/tx_bytes)
            
            RXRATE=$(( (RX2 - RX1) / 1024 / 1024 ))
            TXRATE=$(( (TX2 - TX1) / 1024 / 1024 ))
            
            echo -e "${G}↓ ${RXRATE} MB/s ${R}↑ ${TXRATE} MB/s${N}"
        done
    fi
}

# =====================================================================
#  MAIN EXECUTION
# =====================================================================

show_banner() {
    echo -e "${M}${BOLD}"
    echo "╔═══════════════════════════════════════════════════════╗"
    echo "║              UFTLN v$VERSION - by 0xbv1                   ║"
    echo "║        ULTRA-FAST TERMINAL LINK NETWORK               ║"
    echo "║       github.com/0xb0rn3/uftln                        ║"
    echo "╚═══════════════════════════════════════════════════════╝"
    echo -e "${N}\n"
}

main() {
    show_banner
    optimize_system
    detect_interfaces
    select_protocol
    setup_connection
    select_mode
    setup_paths
    
    echo -e "${M}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${M}${BOLD}║                 TRANSFER STARTING...                  ║${N}"
    echo -e "${M}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    START_TIME=$(date +%s)
    
    case $PROTOCOL in
        sftp) ultra_sftp_transfer ;;
        scp) ultra_scp_transfer ;;
        ftp|ftps) ultra_ftp_transfer ;;
    esac
    
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))
    
    echo -e "\n${G}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${G}${BOLD}║              TRANSFER COMPLETE!                       ║${N}"
    echo -e "${G}${BOLD}║              Duration: ${DURATION}s                          ║${N}"
    echo -e "${G}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    read -p "$(echo -e ${Y}Monitor bandwidth? [y/N]: ${N})" MONITOR
    [[ "$MONITOR" =~ ^[Yy]$ ]] && monitor_bandwidth
}

# Check if running as script
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
