#!/usr/bin/env bash
set -euo pipefail

# =====================================================================
#  UFTLN - ULTRA-FAST TERMINAL LINK NETWORK
#  Coded by: 0xbv1
#  Repo: github.com/0xb0rn3/uftln
# =====================================================================

VERSION="0.0.1"
PARALLEL_JOBS=32
CHUNK_SIZE="8M"
BUFFER_SIZE="131072"

# Colors
G="\e[92m"; R="\e[91m"; Y="\e[93m"; B="\e[94m"; M="\e[95m"; C="\e[96m"; N="\e[0m"; BOLD="\e[1m"

# =====================================================================
#  PLATFORM DETECTION & TERMUX ADAPTATION SYSTEM
# =====================================================================

# Global platform flags - these control feature availability
IS_TERMUX=false
IS_ANDROID=false
IS_DESKTOP_LINUX=false
HAS_ROOT=false
HAS_MAGISK=false
HAS_TRADITIONAL_SUDO=false
CAN_TUNE_KERNEL=false
CAN_SCAN_NETWORK=false
CAN_USE_ETHTOOL=false
CAN_USE_ARP_SCAN=false
CAN_USE_NMAP=false
TERMUX_PREFIX=""

detect_platform() {
    echo -e "${B}${BOLD}[PLATFORM] Detecting environment...${N}"
    
    # First check: Are we in Termux?
    if [[ -n "${TERMUX_VERSION:-}" ]] || [[ -d "/data/data/com.termux" ]]; then
        IS_TERMUX=true
        IS_ANDROID=true
        TERMUX_PREFIX="${PREFIX:-/data/data/com.termux/files/usr}"
        echo -e "${C}✓ Detected: Termux on Android${N}"
    # Second check: Are we on Android but not Termux? (less common)
    elif [[ -d "/system/app" ]] && [[ -d "/system/priv-app" ]]; then
        IS_ANDROID=true
        echo -e "${C}✓ Detected: Android system${N}"
    # Default: We're on desktop Linux
    else
        IS_DESKTOP_LINUX=true
        echo -e "${C}✓ Detected: Desktop Linux${N}"
    fi
    
    # Root detection - this is platform-specific
    if $IS_TERMUX; then
        detect_termux_root
    elif $IS_ANDROID; then
        detect_android_root
    else
        detect_desktop_root
    fi
    
    # Feature capability detection based on platform and root status
    detect_feature_capabilities
    
    echo ""
}

detect_termux_root() {
    echo -e "${Y}[ROOT CHECK] Checking Termux root access...${N}"
    
    # Check if tsu (Termux SU) is available - this indicates Magisk integration
    if command -v tsu >/dev/null 2>&1; then
        # Test if tsu actually works
        if tsu -c "id" >/dev/null 2>&1; then
            HAS_ROOT=true
            HAS_MAGISK=true
            echo -e "${G}✓ Root access available via Magisk (tsu)${N}"
            
            # Check if we can actually modify kernel parameters
            if tsu -c "sysctl -w net.ipv4.tcp_window_scaling=1" >/dev/null 2>&1; then
                CAN_TUNE_KERNEL=true
                echo -e "${G}✓ Kernel tuning available${N}"
            else
                echo -e "${Y}⚠ Root available but kernel tuning blocked (SELinux/kernel config)${N}"
            fi
            return
        fi
    fi
    
    # Check if su binary exists and works (generic root)
    if command -v su >/dev/null 2>&1; then
        if su -c "id" >/dev/null 2>&1; then
            HAS_ROOT=true
            echo -e "${G}✓ Root access available via su${N}"
            
            # Test kernel tuning capability
            if su -c "sysctl -w net.ipv4.tcp_window_scaling=1" >/dev/null 2>&1; then
                CAN_TUNE_KERNEL=true
                echo -e "${G}✓ Kernel tuning available${N}"
            else
                echo -e "${Y}⚠ Root available but kernel tuning blocked${N}"
            fi
            return
        fi
    fi
    
    echo -e "${Y}⚠ No root access detected - some features will be limited${N}"
}

detect_android_root() {
    echo -e "${Y}[ROOT CHECK] Checking Android root access...${N}"
    
    # Check for Magisk su
    if [[ -f "/sbin/su" ]] || [[ -f "/system/xbin/su" ]]; then
        if su -c "id" >/dev/null 2>&1; then
            HAS_ROOT=true
            HAS_MAGISK=true
            echo -e "${G}✓ Magisk root detected${N}"
            return
        fi
    fi
    
    echo -e "${Y}⚠ No root access on Android device${N}"
}

detect_desktop_root() {
    echo -e "${Y}[ROOT CHECK] Checking sudo access...${N}"
    
    # On desktop Linux, check for sudo
    if command -v sudo >/dev/null 2>&1; then
        # Test if sudo works without password (cached credentials) or with password
        if sudo -n true 2>/dev/null; then
            HAS_ROOT=true
            HAS_TRADITIONAL_SUDO=true
            CAN_TUNE_KERNEL=true
            echo -e "${G}✓ Sudo access available (passwordless)${N}"
        elif sudo -v 2>/dev/null; then
            HAS_ROOT=true
            HAS_TRADITIONAL_SUDO=true
            CAN_TUNE_KERNEL=true
            echo -e "${G}✓ Sudo access available${N}"
        else
            echo -e "${Y}⚠ Sudo available but requires password - you'll be prompted when needed${N}"
            HAS_ROOT=true
            HAS_TRADITIONAL_SUDO=true
            CAN_TUNE_KERNEL=true
        fi
    else
        echo -e "${Y}⚠ No sudo available - kernel tuning will be skipped${N}"
    fi
}

detect_feature_capabilities() {
    echo -e "${Y}[FEATURES] Detecting available tools and capabilities...${N}"
    
    # Network scanning tools detection
    if $IS_TERMUX; then
        # In Termux, check for Termux-specific package installations
        if command -v nmap >/dev/null 2>&1; then
            if $HAS_ROOT; then
                CAN_USE_NMAP=true
                CAN_SCAN_NETWORK=true
                echo -e "${G}✓ Nmap available (root required for scanning)${N}"
            else
                echo -e "${Y}⚠ Nmap installed but needs root for network scanning${N}"
            fi
        fi
        
        # arp-scan is rarely available in Termux, even with root
        if command -v arp-scan >/dev/null 2>&1 && $HAS_ROOT; then
            CAN_USE_ARP_SCAN=true
            echo -e "${G}✓ ARP-scan available${N}"
        else
            echo -e "${Y}⚠ ARP-scan not available (will use alternative methods)${N}"
        fi
        
        # ethtool is almost never available on Android
        if command -v ethtool >/dev/null 2>&1; then
            CAN_USE_ETHTOOL=true
            echo -e "${G}✓ Ethtool available${N}"
        else
            echo -e "${Y}⚠ Ethtool not available (interface speed detection limited)${N}"
        fi
        
    else
        # On desktop Linux, these tools are usually available
        CAN_USE_NMAP=$(command -v nmap >/dev/null 2>&1 && echo true || echo false)
        CAN_USE_ARP_SCAN=$(command -v arp-scan >/dev/null 2>&1 && echo true || echo false)
        CAN_USE_ETHTOOL=$(command -v ethtool >/dev/null 2>&1 && echo true || echo false)
        CAN_SCAN_NETWORK=$CAN_USE_NMAP
        
        $CAN_USE_NMAP && echo -e "${G}✓ Nmap available${N}"
        $CAN_USE_ARP_SCAN && echo -e "${G}✓ ARP-scan available${N}"
        $CAN_USE_ETHTOOL && echo -e "${G}✓ Ethtool available${N}"
    fi
    
    # Check for essential transfer tools
    check_transfer_tools
}

check_transfer_tools() {
    local missing_tools=()
    
    # Check for rsync
    if ! command -v rsync >/dev/null 2>&1; then
        missing_tools+=("rsync")
    else
        echo -e "${G}✓ rsync available${N}"
    fi
    
    # Check for SSH client
    if ! command -v ssh >/dev/null 2>&1; then
        missing_tools+=("openssh")
    else
        echo -e "${G}✓ SSH client available${N}"
    fi
    
    # Check for lftp
    if ! command -v lftp >/dev/null 2>&1; then
        missing_tools+=("lftp")
    else
        echo -e "${G}✓ lftp available${N}"
    fi
    
    # If tools are missing, offer to install them
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        echo -e "${Y}⚠ Missing tools: ${missing_tools[*]}${N}"
        echo -e "${C}Would you like to install missing dependencies?${N}"
        read -p "$(echo -e ${Y}[Y/n]: ${N})" INSTALL_CHOICE
        
        if [[ ! "$INSTALL_CHOICE" =~ ^[Nn]$ ]]; then
            install_dependencies_for_platform "${missing_tools[@]}"
        fi
    fi
}

install_dependencies_for_platform() {
    local tools=("$@")
    
    if $IS_TERMUX; then
        echo -e "${M}[INSTALL] Installing packages via pkg (Termux)...${N}"
        pkg update -y 2>/dev/null
        for tool in "${tools[@]}"; do
            case $tool in
                openssh)
                    pkg install -y openssh >/dev/null 2>&1
                    ;;
                *)
                    pkg install -y "$tool" >/dev/null 2>&1
                    ;;
            esac
        done
        echo -e "${G}✓ Installation complete${N}"
    elif $IS_DESKTOP_LINUX; then
        if [[ -f /etc/debian_version ]]; then
            echo -e "${M}[INSTALL] Installing via apt...${N}"
            sudo apt-get update -qq >/dev/null 2>&1
            sudo apt-get install -y rsync lftp openssh-client ethtool nmap arp-scan >/dev/null 2>&1
        elif [[ -f /etc/redhat-release ]]; then
            echo -e "${M}[INSTALL] Installing via dnf...${N}"
            sudo dnf install -y rsync lftp openssh-clients ethtool nmap arp-scan >/dev/null 2>&1
        elif command -v pacman >/dev/null 2>&1; then
            echo -e "${M}[INSTALL] Installing via pacman...${N}"
            sudo pacman -Sy --noconfirm rsync lftp openssh ethtool nmap arp-scan >/dev/null 2>&1
        fi
        echo -e "${G}✓ Installation complete${N}"
    fi
}

# Unified command execution wrapper - automatically uses the right privilege escalation
run_as_root() {
    local cmd="$*"
    
    if $HAS_TRADITIONAL_SUDO; then
        sudo bash -c "$cmd"
    elif $HAS_MAGISK && command -v tsu >/dev/null 2>&1; then
        tsu -c "$cmd"
    elif $HAS_ROOT && command -v su >/dev/null 2>&1; then
        su -c "$cmd"
    else
        # No root available, try anyway and let it fail gracefully
        bash -c "$cmd" 2>/dev/null || true
    fi
}

# Now run the detection
detect_platform
# =====================================================================
#  SYSTEM OPTIMIZATION
# =====================================================================

optimize_system() {
    echo -e "${M}${BOLD}[TURBO] Optimizing system for MAXIMUM SPEED...${N}"
    
    if ! $CAN_TUNE_KERNEL; then
        echo -e "${Y}⚠ Kernel tuning not available on this platform${N}"
        echo -e "${C}  Continuing with default system settings...${N}"
        return
    fi
    
    if ! $HAS_ROOT; then
        echo -e "${Y}⚠ Root access required for system optimization${N}"
        echo -e "${C}  Transfers will work but may not reach maximum speed${N}"
        return
    fi   
    # TCP/Network optimizations
    run_as_root "sysctl -w net.core.rmem_max=134217728" || true
    run_as_root "sysctl -w net.core.wmem_max=134217728" || true
    run_as_root "sysctl -w net.ipv4.tcp_rmem="4096 87380 134217728" || true
    run_as_root "sysctl -w net.ipv4.tcp_wmem="4096 65536 134217728" || true
    run_as_root "sysctl -w net.ipv4.tcp_window_scaling=1" || true
    run_as_root "sysctl -w net.ipv4.tcp_timestamps=1" || true
    run_as_root "sysctl -w net.ipv4.tcp_sack=1" || true
    run_as_root "sysctl -w net.ipv4.tcp_no_metrics_save=1" || true
    run_as_root "sysctl -w net.core.netdev_max_backlog=250000" || true
   
    # BBR congestion control - may not be available on all Android kernels
    if run_as_root "sysctl -w net.ipv4.tcp_congestion_control=bbr" 2>/dev/null; then
        run_as_root "sysctl -w net.core.default_qdisc=fq" || true
        echo -e "${G}✓ BBR congestion control enabled${N}"
    else
        echo -e "${Y}⚠ BBR not available (kernel doesn't support it)${N}"
    fi
    
    run_as_root "sysctl -w net.ipv4.tcp_mtu_probing=1" || true
    
    # File system optimizations - may fail on Android due to different filesystem
    if $IS_DESKTOP_LINUX; then
        run_as_root "sysctl -w fs.file-max=2097152" || true
        run_as_root "sysctl -w vm.swappiness=10" || true
        run_as_root "sysctl -w vm.dirty_ratio=40" || true
        run_as_root "sysctl -w vm.dirty_background_ratio=10" || true
    fi
    
    # Increase file descriptor limit
    ulimit -n 1048576 2>/dev/null || ulimit -n 4096 2>/dev/null || true
    
    echo -e "${G}✓ System optimized within platform capabilities!${N}"
}

# =====================================================================
#  NETWORK INTERFACE DETECTION (Platform-Aware)
# =====================================================================

detect_interfaces() {
    echo -e "${B}${BOLD}[SCAN] Detecting network interfaces...${N}\n"
    
    # Get list of network interfaces, excluding loopback
    mapfile -t IFACES < <(ip -o link show | awk -F': ' '{print $2}' | grep -v "lo")
    
    if [[ ${#IFACES[@]} -eq 0 ]]; then
        echo -e "${R}No network interfaces found!${N}"
        exit 1
    fi
    
    echo -e "${C}Available interfaces:${N}"
    for i in "${!IFACES[@]}"; do
        IFACE="${IFACES[$i]}"
        
        # Get interface speed - platform-dependent
        if $CAN_USE_ETHTOOL; then
            SPEED=$(ethtool "$IFACE" 2>/dev/null | grep -i speed | awk '{print $2}' || echo "Unknown")
        else
            # Fallback method for Android/Termux - check wireless or assume unknown
            if [[ "$IFACE" =~ ^wlan.* ]]; then
                # Try to get WiFi link speed from iw or assume typical WiFi speeds
                if command -v iw >/dev/null 2>&1 && $HAS_ROOT; then
                    SPEED=$(run_as_root "iw dev $IFACE link" 2>/dev/null | grep -i "tx bitrate" | awk '{print $3$4}' || echo "WiFi")
                else
                    SPEED="WiFi"
                fi
            elif [[ "$IFACE" =~ ^rmnet.* ]] || [[ "$IFACE" =~ ^ccmni.* ]]; then
                SPEED="Mobile Data"
            else
                SPEED="Unknown"
            fi
        fi
        
        # Get interface status
        STATUS=$(ip link show "$IFACE" | grep -o "state [A-Z]*" | awk '{print $2}')
        
        # Get IP address
        IP=$(ip -4 addr show "$IFACE" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -1 || echo "No IP")
        
        echo -e "  ${Y}[$((i+1))]${N} ${BOLD}$IFACE${N} - $SPEED - $STATUS - $IP"
    done
    
    echo ""
    read -p "$(echo -e ${Y}Select interface [1-${#IFACES[@]}]: ${N})" IFACE_NUM
    
    if [[ $IFACE_NUM -lt 1 ]] || [[ $IFACE_NUM -gt ${#IFACES[@]} ]]; then
        echo -e "${R}Invalid selection!${N}"
        exit 1
    fi
    
    INTERFACE="${IFACES[$((IFACE_NUM-1))]}"
    echo -e "${G}✓ Using interface: ${BOLD}$INTERFACE${N}\n"
}

# =========================================================
#  NETWORK DISCOVERY & ARP SCAN!
# =========================================================

install_scan_tools() {
    local missing=()
    
    if ! $CAN_USE_NMAP && command -v nmap >/dev/null 2>&1; then
        missing+=("nmap")
    fi
    
    if ! $CAN_USE_ARP_SCAN && command -v arp-scan >/dev/null 2>&1; then
        missing+=("arp-scan")
    fi
    
    if [[ ${#missing[@]} -eq 0 ]]; then
        return 0
    fi
    
    echo -e "${Y}Installing network scanning tools...${N}"
    
    if $IS_TERMUX; then
        pkg install -y nmap >/dev/null 2>&1
        if $HAS_ROOT; then
            echo -e "${G}✓ Nmap installed (root access available for scanning)${N}"
            CAN_USE_NMAP=true
            CAN_SCAN_NETWORK=true
        else
            echo -e "${Y}⚠ Nmap installed but root required for network scanning${N}"
        fi
    elif $IS_DESKTOP_LINUX; then
        install_dependencies_for_platform "${missing[@]}"
        CAN_USE_NMAP=true
        CAN_USE_ARP_SCAN=true
        CAN_SCAN_NETWORK=true
    fi
}

scan_network() {
    if ! $CAN_SCAN_NETWORK; then
        echo -e "${Y}⚠ Network scanning not available on this platform${N}"
        if $IS_TERMUX && ! $HAS_ROOT; then
            echo -e "${C}  Network scanning requires root access on Android${N}"
        fi
        return 1
    fi
    
    echo -e "${M}${BOLD}[DISCOVERY] Scanning network for available servers...${N}"
    
    # Get network subnet
    LOCAL_IP=$(ip -4 addr show "$INTERFACE" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -1)
    SUBNET=$(ip -4 addr show "$INTERFACE" | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -1)
    
    if [[ -z "$SUBNET" ]]; then
        echo -e "${R}Could not determine subnet for $INTERFACE${N}"
        return 1
    fi
    
    echo -e "${C}Scanning subnet: ${BOLD}$SUBNET${N}"
    echo -e "${Y}This may take 10-30 seconds...${N}\n"
    
    declare -A DISCOVERED_HOSTS
    
    # ARP scan if available
    if $CAN_USE_ARP_SCAN; then
        echo -e "${C}[ARP SCAN] Fast discovery mode...${N}"
        while IFS=$'\t' read -r ip mac vendor; do
            [[ "$ip" == "$LOCAL_IP" ]] && continue
            DISCOVERED_HOSTS["$ip"]="$mac | $vendor"
        done < <(run_as_root "arp-scan --interface=$INTERFACE --localnet 2>/dev/null | grep -E '^[0-9]+\.' | awk '{print \$1\"\t\"\$2\"\t\"\$3\" \"\$4\" \"\$5}'")
    fi
    
    # Nmap scan for service detection
    if $CAN_USE_NMAP; then
        echo -e "${C}[NMAP SCAN] Detecting FTP/SSH services...${N}"
        local temp_file=$(mktemp)
        
        if $HAS_ROOT; then
            run_as_root "nmap -p 21,22,990,989 -T4 --open $SUBNET -oG $temp_file" >/dev/null 2>&1
        else
            nmap -p 21,22,990,989 -T4 --open "$SUBNET" -oG "$temp_file" >/dev/null 2>&1
        fi
        
        while read -r line; do
            if [[ $line =~ Host:\ ([0-9.]+)\ \(.*Ports:\ (.+) ]]; then
                local ip="${BASH_REMATCH[1]}"
                local ports="${BASH_REMATCH[2]}"
                
                [[ "$ip" == "$LOCAL_IP" ]] && continue
                
                local services=""
                [[ $ports =~ 21/open ]] && services+="FTP "
                [[ $ports =~ 22/open ]] && services+="SSH "
                [[ $ports =~ 990/open ]] && services+="FTPS "
                [[ $ports =~ 989/open ]] && services+="FTPS "
                
                if [[ -n "$services" ]]; then
                    if [[ -n "${DISCOVERED_HOSTS[$ip]:-}" ]]; then
                        DISCOVERED_HOSTS["$ip"]="${DISCOVERED_HOSTS[$ip]} | Services: $services"
                    else
                        DISCOVERED_HOSTS["$ip"]="Unknown MAC | Services: $services"
                    fi
                fi
            fi
        done < "$temp_file"
        rm -f "$temp_file"
    fi
    
    # Display results
    if [[ ${#DISCOVERED_HOSTS[@]} -eq 0 ]]; then
        echo -e "${Y}No servers with FTP/SSH services detected on network${N}\n"
        return 1
    fi
    
    echo -e "${G}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${G}${BOLD}║           DISCOVERED SERVERS ON NETWORK               ║${N}"
    echo -e "${G}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    local -a IP_ARRAY
    local idx=1
    
    for ip in "${!DISCOVERED_HOSTS[@]}"; do
        IP_ARRAY+=("$ip")
        echo -e "  ${Y}[$idx]${N} ${BOLD}$ip${N}"
        echo -e "      ${C}${DISCOVERED_HOSTS[$ip]}${N}"
        echo ""
        ((idx++))
    done
    
    echo -e "${Y}[0]${N} Manually enter server details"
    echo -e "${Y}[R]${N} Rescan network"
    echo ""
    
    read -p "$(echo -e ${Y}Select server [0-${#IP_ARRAY[@]}] or R: ${N})" SERVER_CHOICE
    
    if [[ "$SERVER_CHOICE" =~ ^[Rr]$ ]]; then
        scan_network
        return $?
    elif [[ "$SERVER_CHOICE" == "0" ]]; then
        return 1
    elif [[ $SERVER_CHOICE -ge 1 ]] && [[ $SERVER_CHOICE -le ${#IP_ARRAY[@]} ]]; then
        HOST="${IP_ARRAY[$((SERVER_CHOICE-1))]}"
        echo -e "${G}✓ Selected: ${BOLD}$HOST${N}\n"
        return 0
    else
        echo -e "${R}Invalid selection!${N}"
        return 1
    fi
}

show_banner() {
    echo -e "${M}${BOLD}"
    echo "╔═══════════════════════════════════════════════════════╗"
    echo "║              UFTLN v$VERSION - by 0xbv1                   ║"
    echo "║        ULTRA-FAST TERMINAL LINK NETWORK               ║"
    echo "║       github.com/0xb0rn3/uftln                        ║"
    
    # Show platform-specific info
    if $IS_TERMUX; then
        echo "║                                                       ║"
        echo "║  Platform: Termux/Android $([ "$HAS_ROOT" = true ] && echo "(Rooted)" || echo "(Non-root)")                    ║"
    elif $IS_ANDROID; then
        echo "║                                                       ║"
        echo "║  Platform: Android $([ "$HAS_ROOT" = true ] && echo "(Rooted)" || echo "(Non-root)")                          ║"
    else
        echo "║                                                       ║"
        echo "║  Platform: Desktop Linux                             ║"
    fi
    
    echo "╚═══════════════════════════════════════════════════════╝"
    echo -e "${N}\n"
}

# =====================================================================
#  STEALTHY HOST DETECTION
# =====================================================================

stealthy_ping() {
    local target="$1"
    local spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
    local delay=0.1
    
    # Show scanning animation
    echo -ne "${Y}[⠋] Checking host availability...${N}\r"
    
    # Stealthy ping - single packet, no DNS, low TTL
    local result=0
    if ping -c 1 -W 1 -n -t 32 "$target" >/dev/null 2>&1; then
        result=1
    elif timeout 2 bash -c "exec 3<>/dev/tcp/$target/22" >/dev/null 2>&1; then
        # Fallback: check if SSH port is open
        result=1
    elif timeout 2 bash -c "exec 3<>/dev/tcp/$target/21" >/dev/null 2>&1; then
        # Fallback: check if FTP port is open
        result=1
    fi
    
    # Animate through spinner frames
    local spinchars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
    for i in {0..9}; do
        local char="${spinchars:$i:1}"
        echo -ne "${Y}[$char] Checking host availability...${N}\r"
        sleep $delay
    done
    
    # Clear line and show result
    echo -ne "\r\033[K"
    
    if [[ $result -eq 1 ]]; then
        # Animated green indicator
        for i in {1..3}; do
            echo -ne "${G}[●] $target - Online${N}\r"
            sleep 0.15
            echo -ne "${G}[○] $target - Online${N}\r"
            sleep 0.15
        done
        echo -e "${G}[●] $target - Online${N}"
        return 0
    else
        echo -e "${R}[✗] $target - Offline or unreachable${N}"
        echo -ne "${Y}    Continue anyway? [y/N]: ${N}"
        read -r continue_choice
        [[ "$continue_choice" =~ ^[Yy]$ ]] && return 0 || return 1
    fi
}

select_protocol() {
    echo -e "${M}${BOLD}[PROTOCOL] Select transfer protocol:${N}"
    echo -e "  ${Y}[1]${N} FTP (Fast, unencrypted)"
    echo -e "  ${Y}[2]${N} FTPS (FTP over SSL/TLS)"
    echo -e "  ${Y}[3]${N} SFTP (SSH File Transfer - RECOMMENDED)"
    echo -e "  ${Y}[4]${N} SCP (Secure Copy - Ultra fast)"
    echo ""
    read -p "$(echo -e ${Y}Choice [1-4]: ${N})" PROTO_CHOICE
    
    case $PROTO_CHOICE in
        1) PROTOCOL="ftp" ;;
        2) PROTOCOL="ftps" ;;
        3) PROTOCOL="sftp" ;;
        4) PROTOCOL="scp" ;;
        *) echo -e "${R}Invalid choice!${N}"; exit 1 ;;
    esac
    
    echo -e "${G}✓ Protocol: ${BOLD}${PROTOCOL^^}${N}\n"
}

# =====================================================================
#  CONNECTION SETUP
# =====================================================================

setup_connection() {
    echo -e "${C}${BOLD}[CONNECT] Connection setup${N}\n"
    
    echo -e "${Y}Would you like to scan the network for available servers?${N}"
    read -p "$(echo -e ${Y}[Y/n]: ${N})" SCAN_CHOICE
    
    if [[ ! "$SCAN_CHOICE" =~ ^[Nn]$ ]]; then
        install_scan_tools
        if scan_network; then
            # HOST was set by scan_network
            :
        else
            # Manual entry
            read -p "$(echo -e ${Y}Host: ${N})" HOST
            if ! stealthy_ping "$HOST"; then
                echo -e "${R}Aborting connection setup.${N}"
                exit 1
            fi
        fi
    else
        read -p "$(echo -e ${Y}Host: ${N})" HOST
        if ! stealthy_ping "$HOST"; then
            echo -e "${R}Aborting connection setup.${N}"
            exit 1
        fi
    fi
    
    read -p "$(echo -e ${Y}Username: ${N})" USERNAME
    read -p "$(echo -e ${Y}Port [default 21/22]: ${N})" PORT
    
    if [[ -z "$PORT" ]]; then
        [[ "$PROTOCOL" == "ftp" || "$PROTOCOL" == "ftps" ]] && PORT=21 || PORT=22
    fi
    
    if [[ "$PROTOCOL" == "sftp" || "$PROTOCOL" == "scp" ]]; then
        read -p "$(echo -e ${Y}SSH key path [press Enter for password]: ${N})" SSH_KEY
    fi
    
    CONNECTION_STRING="$USERNAME@$HOST:$PORT"
    echo -e "${G}✓ Connection: ${BOLD}$CONNECTION_STRING${N}\n"
}

# =====================================================================
#  MODE SELECTION
# =====================================================================

select_mode() {
    echo -e "${M}${BOLD}[MODE] Select operation:${N}"
    echo -e "  ${Y}[1]${N} Upload (Local → Remote)"
    echo -e "  ${Y}[2]${N} Download (Remote → Local)"
    echo -e "  ${Y}[3]${N} Sync (Bidirectional)"
    echo -e "  ${Y}[4]${N} Mass Upload (Multiple files/folders)"
    echo -e "  ${Y}[5]${N} Mass Download (Multiple remote paths)"
    echo ""
    read -p "$(echo -e ${Y}Choice [1-5]: ${N})" MODE_CHOICE
    
    case $MODE_CHOICE in
        1) MODE="upload" ;;
        2) MODE="download" ;;
        3) MODE="sync" ;;
        4) MODE="mass_upload" ;;
        5) MODE="mass_download" ;;
        *) echo -e "${R}Invalid choice!${N}"; exit 1 ;;
    esac
    
    echo -e "${G}✓ Mode: ${BOLD}${MODE^^}${N}\n"
}

# =====================================================================
#  PATH SETUP
# =====================================================================

setup_paths() {
    if [[ "$MODE" == "upload" || "$MODE" == "sync" ]]; then
        read -p "$(echo -e ${Y}Local path to transfer: ${N})" LOCAL_PATH
        if [[ ! -e "$LOCAL_PATH" ]]; then
            echo -e "${R}Path doesn't exist!${N}"
            exit 1
        fi
    fi
    
    if [[ "$MODE" == "mass_upload" ]]; then
        echo -e "${C}Enter local paths to upload (one per line, empty line to finish):${N}"
        LOCAL_PATHS=()
        while true; do
            read -p "$(echo -e ${Y}Path $((${#LOCAL_PATHS[@]}+1)): ${N})" path
            [[ -z "$path" ]] && break
            if [[ ! -e "$path" ]]; then
                echo -e "${R}Path doesn't exist! Skipping...${N}"
                continue
            fi
            LOCAL_PATHS+=("$path")
            echo -e "${G}✓ Added: $path${N}"
        done
        
        if [[ ${#LOCAL_PATHS[@]} -eq 0 ]]; then
            echo -e "${R}No valid paths provided!${N}"
            exit 1
        fi
        echo -e "${C}Total paths: ${BOLD}${#LOCAL_PATHS[@]}${N}\n"
    fi
    
    if [[ "$MODE" == "mass_download" ]]; then
        echo -e "${C}Enter remote paths to download (one per line, empty line to finish):${N}"
        REMOTE_PATHS=()
        while true; do
            read -p "$(echo -e ${Y}Remote path $((${#REMOTE_PATHS[@]}+1)): ${N})" path
            [[ -z "$path" ]] && break
            REMOTE_PATHS+=("$path")
            echo -e "${G}✓ Added: $path${N}"
        done
        
        if [[ ${#REMOTE_PATHS[@]} -eq 0 ]]; then
            echo -e "${R}No valid paths provided!${N}"
            exit 1
        fi
        echo -e "${C}Total paths: ${BOLD}${#REMOTE_PATHS[@]}${N}\n"
    fi
    
    if [[ "$MODE" == "download" || "$MODE" == "sync" ]]; then
        read -p "$(echo -e ${Y}Remote path to transfer: ${N})" REMOTE_PATH
    fi
    
    if [[ "$MODE" == "upload" ]]; then
        read -p "$(echo -e ${Y}Remote destination [default /]: ${N})" REMOTE_PATH
        [[ -z "$REMOTE_PATH" ]] && REMOTE_PATH="/"
    fi
    
    if [[ "$MODE" == "download" ]]; then
        read -p "$(echo -e ${Y}Local destination [default ./downloads]: ${N})" LOCAL_PATH
        [[ -z "$LOCAL_PATH" ]] && LOCAL_PATH="./downloads"
        mkdir -p "$LOCAL_PATH"
    fi
    
    if [[ "$MODE" == "mass_upload" ]]; then
        read -p "$(echo -e ${Y}Remote destination directory [default /]: ${N})" REMOTE_PATH
        [[ -z "$REMOTE_PATH" ]] && REMOTE_PATH="/"
    fi
    
    if [[ "$MODE" == "mass_download" ]]; then
        read -p "$(echo -e ${Y}Local destination directory [default ./downloads]: ${N})" LOCAL_PATH
        [[ -z "$LOCAL_PATH" ]] && LOCAL_PATH="./downloads"
        mkdir -p "$LOCAL_PATH"
    fi
}

# =====================================================================
#  ULTRA-FAST TRANSFERS
# =====================================================================

ultra_sftp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating ULTRA-FAST SFTP...${N}\n"
    
    SSH_OPTS="-o Compression=no -o Ciphers=aes128-gcm@openssh.com,aes256-gcm@openssh.com -o MACs=umac-128@openssh.com"
    [[ -n "${SSH_KEY:-}" ]] && SSH_OPTS="$SSH_OPTS -i $SSH_KEY"
    
    if [[ "$MODE" == "upload" ]]; then
        if [[ -d "$LOCAL_PATH" ]]; then
            echo -e "${G}[BEAST MODE] Parallel directory upload...${N}"
            rsync -avz --progress --stats \
                -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
                --bwlimit=0 \
                --partial --partial-dir=.rsync-partial \
                --inplace \
                "$LOCAL_PATH/" "$USERNAME@$HOST:$REMOTE_PATH"
        else
            scp -P "$PORT" $SSH_OPTS -o TCPRcvBufPoll=yes \
                -o TCPRcvBuf=$BUFFER_SIZE \
                "$LOCAL_PATH" "$USERNAME@$HOST:$REMOTE_PATH"
        fi
    elif [[ "$MODE" == "download" ]]; then
        echo -e "${G}[BEAST MODE] Parallel download...${N}"
        rsync -avz --progress --stats \
            -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
            --bwlimit=0 \
            --partial --partial-dir=.rsync-partial \
            --inplace \
            "$USERNAME@$HOST:$REMOTE_PATH" "$LOCAL_PATH/"
    elif [[ "$MODE" == "sync" ]]; then
        echo -e "${G}[SYNC MODE] Bidirectional sync...${N}"
        rsync -avz --progress --stats \
            -e "ssh -p $PORT $SSH_OPTS" \
            --delete \
            "$LOCAL_PATH/" "$USERNAME@$HOST:$REMOTE_PATH"
    elif [[ "$MODE" == "mass_upload" ]]; then
        echo -e "${G}[MASS UPLOAD] Transferring ${#LOCAL_PATHS[@]} items...${N}\n"
        local completed=0
        local failed=0
        
        for path in "${LOCAL_PATHS[@]}"; do
            local basename=$(basename "$path")
            echo -e "${C}[${G}$((completed+1))${C}/${#LOCAL_PATHS[@]}] Uploading: ${BOLD}$basename${N}"
            
            if [[ -d "$path" ]]; then
                if rsync -avz --progress \
                    -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
                    --bwlimit=0 \
                    --partial --partial-dir=.rsync-partial \
                    --inplace \
                    "$path/" "$USERNAME@$HOST:$REMOTE_PATH/$basename/" 2>/dev/null; then
                    echo -e "${G}✓ Completed: $basename${N}\n"
                    ((completed++))
                else
                    echo -e "${R}✗ Failed: $basename${N}\n"
                    ((failed++))
                fi
            else
                if scp -P "$PORT" $SSH_OPTS "$path" "$USERNAME@$HOST:$REMOTE_PATH/" 2>/dev/null; then
                    echo -e "${G}✓ Completed: $basename${N}\n"
                    ((completed++))
                else
                    echo -e "${R}✗ Failed: $basename${N}\n"
                    ((failed++))
                fi
            fi
        done
        
        echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
    elif [[ "$MODE" == "mass_download" ]]; then
        echo -e "${G}[MASS DOWNLOAD] Transferring ${#REMOTE_PATHS[@]} items...${N}\n"
        local completed=0
        local failed=0
        
        for path in "${REMOTE_PATHS[@]}"; do
            local basename=$(basename "$path")
            echo -e "${C}[${G}$((completed+1))${C}/${#REMOTE_PATHS[@]}] Downloading: ${BOLD}$basename${N}"
            
            if rsync -avz --progress \
                -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
                --bwlimit=0 \
                --partial --partial-dir=.rsync-partial \
                --inplace \
                "$USERNAME@$HOST:$path" "$LOCAL_PATH/" 2>/dev/null; then
                echo -e "${G}✓ Completed: $basename${N}\n"
                ((completed++))
            else
                echo -e "${R}✗ Failed: $basename${N}\n"
                ((failed++))
            fi
        done
        
        echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
    fi
}

ultra_scp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating ULTRA-FAST SCP...${N}\n"
    
    SSH_OPTS="-o Compression=no -c aes128-gcm@openssh.com -o MACs=umac-128@openssh.com"
    [[ -n "${SSH_KEY:-}" ]] && SSH_OPTS="$SSH_OPTS -i $SSH_KEY"
    
    if [[ "$MODE" == "upload" ]]; then
        scp -P "$PORT" $SSH_OPTS -r "$LOCAL_PATH" "$USERNAME@$HOST:$REMOTE_PATH"
    elif [[ "$MODE" == "download" ]]; then
        scp -P "$PORT" $SSH_OPTS -r "$USERNAME@$HOST:$REMOTE_PATH" "$LOCAL_PATH"
    elif [[ "$MODE" == "mass_upload" ]]; then
        echo -e "${G}[MASS UPLOAD] Transferring ${#LOCAL_PATHS[@]} items...${N}\n"
        local completed=0
        local failed=0
        
        for path in "${LOCAL_PATHS[@]}"; do
            local basename=$(basename "$path")
            echo -e "${C}[${G}$((completed+1))${C}/${#LOCAL_PATHS[@]}] Uploading: ${BOLD}$basename${N}"
            
            if scp -P "$PORT" $SSH_OPTS -r "$path" "$USERNAME@$HOST:$REMOTE_PATH/" 2>/dev/null; then
                echo -e "${G}✓ Completed: $basename${N}\n"
                ((completed++))
            else
                echo -e "${R}✗ Failed: $basename${N}\n"
                ((failed++))
            fi
        done
        
        echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
    elif [[ "$MODE" == "mass_download" ]]; then
        echo -e "${G}[MASS DOWNLOAD] Transferring ${#REMOTE_PATHS[@]} items...${N}\n"
        local completed=0
        local failed=0
        
        for path in "${REMOTE_PATHS[@]}"; do
            local basename=$(basename "$path")
            echo -e "${C}[${G}$((completed+1))${C}/${#REMOTE_PATHS[@]}] Downloading: ${BOLD}$basename${N}"
            
            if scp -P "$PORT" $SSH_OPTS -r "$USERNAME@$HOST:$path" "$LOCAL_PATH/" 2>/dev/null; then
                echo -e "${G}✓ Completed: $basename${N}\n"
                ((completed++))
            else
                echo -e "${R}✗ Failed: $basename${N}\n"
                ((failed++))
            fi
        done
        
        echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
    fi
}

ultra_ftp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating FTP transfer...${N}\n"
    
    if command -v lftp >/dev/null 2>&1; then
        LFTP_CMD="lftp -u $USERNAME -p $PORT"
        [[ "$PROTOCOL" == "ftps" ]] && LFTP_CMD="$LFTP_CMD -e 'set ftp:ssl-force true'"
        
        if [[ "$MODE" == "upload" ]]; then
            $LFTP_CMD <<EOF
open $HOST
mirror -R --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$LOCAL_PATH" "$REMOTE_PATH"
bye
EOF
        elif [[ "$MODE" == "download" ]]; then
            $LFTP_CMD <<EOF
open $HOST
mirror --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$REMOTE_PATH" "$LOCAL_PATH"
bye
EOF
        elif [[ "$MODE" == "mass_upload" ]]; then
            echo -e "${G}[MASS UPLOAD] Transferring ${#LOCAL_PATHS[@]} items...${N}\n"
            local completed=0
            local failed=0
            
            for path in "${LOCAL_PATHS[@]}"; do
                local basename=$(basename "$path")
                echo -e "${C}[${G}$((completed+1))${C}/${#LOCAL_PATHS[@]}] Uploading: ${BOLD}$basename${N}"
                
                if $LFTP_CMD <<EOF
open $HOST
mirror -R --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$path" "$REMOTE_PATH/$basename"
bye
EOF
                then
                    echo -e "${G}✓ Completed: $basename${N}\n"
                    ((completed++))
                else
                    echo -e "${R}✗ Failed: $basename${N}\n"
                    ((failed++))
                fi
            done
            
            echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
        elif [[ "$MODE" == "mass_download" ]]; then
            echo -e "${G}[MASS DOWNLOAD] Transferring ${#REMOTE_PATHS[@]} items...${N}\n"
            local completed=0
            local failed=0
            
            for path in "${REMOTE_PATHS[@]}"; do
                local basename=$(basename "$path")
                echo -e "${C}[${G}$((completed+1))${C}/${#REMOTE_PATHS[@]}] Downloading: ${BOLD}$basename${N}"
                
                if $LFTP_CMD <<EOF
open $HOST
mirror --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$path" "$LOCAL_PATH/$basename"
bye
EOF
                then
                    echo -e "${G}✓ Completed: $basename${N}\n"
                    ((completed++))
                else
                    echo -e "${R}✗ Failed: $basename${N}\n"
                    ((failed++))
                fi
            done
            
            echo -e "${G}${BOLD}Summary: $completed succeeded, $failed failed${N}"
        fi
    else
        echo -e "${Y}Installing lftp for maximum FTP performance...${N}"
        sudo apt-get install -y lftp 2>/dev/null || sudo dnf install -y lftp 2>/dev/null || sudo pacman -S --noconfirm lftp
        ultra_ftp_transfer
    fi
}

# =====================================================================
#  BANDWIDTH MONITOR
# =====================================================================

monitor_bandwidth() {
    echo -e "${C}${BOLD}[MONITOR] Real-time bandwidth (Ctrl+C to stop)${N}\n"
    
    if command -v iftop >/dev/null 2>&1; then
        sudo iftop -i "$INTERFACE" -t -s 1
    elif command -v nload >/dev/null 2>&1; then
        nload "$INTERFACE"
    else
        while true; do
            if [ ! -d /sys/class/net/"$INTERFACE" ]; then
                echo "Error: Network interface '$INTERFACE' not found."
                break
            fi
            
            RX1=$(cat /sys/class/net/"$INTERFACE"/statistics/rx_bytes)
            TX1=$(cat /sys/class/net/"$INTERFACE"/statistics/tx_bytes)
            sleep 1
            RX2=$(cat /sys/class/net/"$INTERFACE"/statistics/rx_bytes)
            TX2=$(cat /sys/class/net/"$INTERFACE"/statistics/tx_bytes)
            
            RXRATE=$(( (RX2 - RX1) / 1024 / 1024 ))
            TXRATE=$(( (TX2 - TX1) / 1024 / 1024 ))
            
            echo -e "${G}↓ ${RXRATE} MB/s ${R}↑ ${TXRATE} MB/s${N}"
        done
    fi
}

# =====================================================================
#  MAIN EXECUTION
# =====================================================================

show_banner() {
    echo -e "${M}${BOLD}"
    echo "╔═══════════════════════════════════════════════════════╗"
    echo "║              UFTLN v$VERSION - by 0xbv1                   ║"
    echo "║        ULTRA-FAST TERMINAL LINK NETWORK               ║"
    echo "║       github.com/0xb0rn3/uftln                        ║"
    echo "╚═══════════════════════════════════════════════════════╝"
    echo -e "${N}\n"
}

main() {
    show_banner
    optimize_system
    detect_interfaces
    select_protocol
    setup_connection
    select_mode
    setup_paths
    
    echo -e "${M}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${M}${BOLD}║                 TRANSFER STARTING...                  ║${N}"
    echo -e "${M}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    START_TIME=$(date +%s)
    
    case $PROTOCOL in
        sftp) ultra_sftp_transfer ;;
        scp) ultra_scp_transfer ;;
        ftp|ftps) ultra_ftp_transfer ;;
    esac
    
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))
    
    echo -e "\n${G}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${G}${BOLD}║              TRANSFER COMPLETE!                       ║${N}"
    echo -e "${G}${BOLD}║              Duration: ${DURATION}s                          ║${N}"
    echo -e "${G}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    read -p "$(echo -e ${Y}Monitor bandwidth? [y/N]: ${N})" MONITOR
    [[ "$MONITOR" =~ ^[Yy]$ ]] && monitor_bandwidth
}

# Check if running as script
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
\t' read -r ip mac vendor; do
            [[ "$ip" == "$LOCAL_IP" ]] && continue
            DISCOVERED_HOSTS["$ip"]="$mac | $vendor"
        done < <(sudo arp-scan --interface="$INTERFACE" --localnet 2>/dev/null | grep -E '^[0-9]+\.' | awk '{print $1"\t"$2"\t"$3" "$4" "$5}')
    fi
    
    # Nmap scan for service detection
    if command -v nmap >/dev/null 2>&1; then
        local temp_file=$(mktemp)
        nmap -p 21,22,990,989 -T4 --open "$SUBNET" -oG "$temp_file" >/dev/null 2>&1
        
        while read -r line; do
            if [[ $line =~ Host:\ ([0-9.]+)\ \(.*Ports:\ (.+) ]]; then
                local ip="${BASH_REMATCH[1]}"
                local ports="${BASH_REMATCH[2]}"
                
                [[ "$ip" == "$LOCAL_IP" ]] && continue
                
                local services=""
                [[ $ports =~ 21/open ]] && services+="FTP "
                [[ $ports =~ 22/open ]] && services+="SSH "
                [[ $ports =~ 990/open ]] && services+="FTPS "
                [[ $ports =~ 989/open ]] && services+="FTPS "
                
                if [[ -n "$services" ]]; then
                    if [[ -n "${DISCOVERED_HOSTS[$ip]:-}" ]]; then
                        DISCOVERED_HOSTS["$ip"]="${DISCOVERED_HOSTS[$ip]} | Services: $services"
                    else
                        DISCOVERED_HOSTS["$ip"]="Unknown MAC | Services: $services"
                    fi
                fi
            fi
        done < "$temp_file"
        rm -f "$temp_file"
    fi
    
    # Display results
    if [[ ${#DISCOVERED_HOSTS[@]} -eq 0 ]]; then
        echo -e "${Y}No servers with FTP/SSH services detected on network${N}\n"
        return 1
    fi
    
    echo -e "${G}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${G}${BOLD}║           DISCOVERED SERVERS ON NETWORK               ║${N}"
    echo -e "${G}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    local -a IP_ARRAY
    local idx=1
    
    for ip in "${!DISCOVERED_HOSTS[@]}"; do
        IP_ARRAY+=("$ip")
        echo -e "  ${Y}[$idx]${N} ${BOLD}$ip${N}"
        echo -e "      ${C}${DISCOVERED_HOSTS[$ip]}${N}"
        echo ""
        ((idx++))
    done
    
    echo -e "${Y}[0]${N} Manually enter server details"
    echo -e "${Y}[R]${N} Rescan network"
    echo ""
    
    read -p "$(echo -e ${Y}Select server [0-${#IP_ARRAY[@]}] or R: ${N})" SERVER_CHOICE
    
    if [[ "$SERVER_CHOICE" =~ ^[Rr]$ ]]; then
        scan_network
        return $?
    elif [[ "$SERVER_CHOICE" == "0" ]]; then
        return 1
    elif [[ $SERVER_CHOICE -ge 1 ]] && [[ $SERVER_CHOICE -le ${#IP_ARRAY[@]} ]]; then
        HOST="${IP_ARRAY[$((SERVER_CHOICE-1))]}"
        echo -e "${G}✓ Selected: ${BOLD}$HOST${N}\n"
        return 0
    else
        echo -e "${R}Invalid selection!${N}"
        return 1
    fi
}

# =====================================================================
#  PROTOCOL SELECTION
# =====================================================================

select_protocol() {
    echo -e "${M}${BOLD}[PROTOCOL] Select transfer protocol:${N}"
    echo -e "  ${Y}[1]${N} FTP (Fast, unencrypted)"
    echo -e "  ${Y}[2]${N} FTPS (FTP over SSL/TLS)"
    echo -e "  ${Y}[3]${N} SFTP (SSH File Transfer - RECOMMENDED)"
    echo -e "  ${Y}[4]${N} SCP (Secure Copy - Ultra fast)"
    echo ""
    read -p "$(echo -e ${Y}Choice [1-4]: ${N})" PROTO_CHOICE
    
    case $PROTO_CHOICE in
        1) PROTOCOL="ftp" ;;
        2) PROTOCOL="ftps" ;;
        3) PROTOCOL="sftp" ;;
        4) PROTOCOL="scp" ;;
        *) echo -e "${R}Invalid choice!${N}"; exit 1 ;;
    esac
    
    echo -e "${G}✓ Protocol: ${BOLD}${PROTOCOL^^}${N}\n"
}

# =====================================================================
#  CONNECTION SETUP
# =====================================================================

setup_connection() {
    echo -e "${C}${BOLD}[CONNECT] Connection setup${N}\n"
    
    echo -e "${Y}Would you like to scan the network for available servers?${N}"
    read -p "$(echo -e ${Y}[Y/n]: ${N})" SCAN_CHOICE
    
    if [[ ! "$SCAN_CHOICE" =~ ^[Nn]$ ]]; then
        install_scan_tools
        if scan_network; then
            # HOST was set by scan_network
            :
        else
            # Manual entry
            read -p "$(echo -e ${Y}Host: ${N})" HOST
        fi
    else
        read -p "$(echo -e ${Y}Host: ${N})" HOST
    fi
    
    read -p "$(echo -e ${Y}Username: ${N})" USERNAME
    read -p "$(echo -e ${Y}Port [default 21/22]: ${N})" PORT
    
    if [[ -z "$PORT" ]]; then
        [[ "$PROTOCOL" == "ftp" || "$PROTOCOL" == "ftps" ]] && PORT=21 || PORT=22
    fi
    
    if [[ "$PROTOCOL" == "sftp" || "$PROTOCOL" == "scp" ]]; then
        read -p "$(echo -e ${Y}SSH key path [press Enter for password]: ${N})" SSH_KEY
    fi
    
    CONNECTION_STRING="$USERNAME@$HOST:$PORT"
    echo -e "${G}✓ Connection: ${BOLD}$CONNECTION_STRING${N}\n"
}

# =====================================================================
#  MODE SELECTION
# =====================================================================

select_mode() {
    echo -e "${M}${BOLD}[MODE] Select operation:${N}"
    echo -e "  ${Y}[1]${N} Upload (Local → Remote)"
    echo -e "  ${Y}[2]${N} Download (Remote → Local)"
    echo -e "  ${Y}[3]${N} Sync (Bidirectional)"
    echo ""
    read -p "$(echo -e ${Y}Choice [1-3]: ${N})" MODE_CHOICE
    
    case $MODE_CHOICE in
        1) MODE="upload" ;;
        2) MODE="download" ;;
        3) MODE="sync" ;;
        *) echo -e "${R}Invalid choice!${N}"; exit 1 ;;
    esac
    
    echo -e "${G}✓ Mode: ${BOLD}${MODE^^}${N}\n"
}

# =====================================================================
#  PATH SETUP
# =====================================================================

setup_paths() {
    if [[ "$MODE" == "upload" || "$MODE" == "sync" ]]; then
        read -p "$(echo -e ${Y}Local path to transfer: ${N})" LOCAL_PATH
        if [[ ! -e "$LOCAL_PATH" ]]; then
            echo -e "${R}Path doesn't exist!${N}"
            exit 1
        fi
    fi
    
    if [[ "$MODE" == "download" || "$MODE" == "sync" ]]; then
        read -p "$(echo -e ${Y}Remote path to transfer: ${N})" REMOTE_PATH
    fi
    
    if [[ "$MODE" == "upload" ]]; then
        read -p "$(echo -e ${Y}Remote destination [default /]: ${N})" REMOTE_PATH
        [[ -z "$REMOTE_PATH" ]] && REMOTE_PATH="/"
    fi
    
    if [[ "$MODE" == "download" ]]; then
        read -p "$(echo -e ${Y}Local destination [default ./downloads]: ${N})" LOCAL_PATH
        [[ -z "$LOCAL_PATH" ]] && LOCAL_PATH="./downloads"
        mkdir -p "$LOCAL_PATH"
    fi
}

# =====================================================================
#  ULTRA-FAST TRANSFERS
# =====================================================================

ultra_sftp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating ULTRA-FAST SFTP...${N}\n"
    
    SSH_OPTS="-o Compression=no -o Ciphers=aes128-gcm@openssh.com,aes256-gcm@openssh.com -o MACs=umac-128@openssh.com"
    [[ -n "${SSH_KEY:-}" ]] && SSH_OPTS="$SSH_OPTS -i $SSH_KEY"
    
    if [[ "$MODE" == "upload" ]]; then
        if [[ -d "$LOCAL_PATH" ]]; then
            echo -e "${G}[BEAST MODE] Parallel directory upload...${N}"
            rsync -avz --progress --stats \
                -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
                --bwlimit=0 \
                --partial --partial-dir=.rsync-partial \
                --inplace \
                "$LOCAL_PATH/" "$USERNAME@$HOST:$REMOTE_PATH"
        else
            scp -P "$PORT" $SSH_OPTS -o TCPRcvBufPoll=yes \
                -o TCPRcvBuf=$BUFFER_SIZE \
                "$LOCAL_PATH" "$USERNAME@$HOST:$REMOTE_PATH"
        fi
    elif [[ "$MODE" == "download" ]]; then
        echo -e "${G}[BEAST MODE] Parallel download...${N}"
        rsync -avz --progress --stats \
            -e "ssh -p $PORT $SSH_OPTS -o ControlMaster=auto -o ControlPath=/tmp/ssh-%r@%h:%p -o ControlPersist=600" \
            --bwlimit=0 \
            --partial --partial-dir=.rsync-partial \
            --inplace \
            "$USERNAME@$HOST:$REMOTE_PATH" "$LOCAL_PATH/"
    else
        echo -e "${G}[SYNC MODE] Bidirectional sync...${N}"
        rsync -avz --progress --stats \
            -e "ssh -p $PORT $SSH_OPTS" \
            --delete \
            "$LOCAL_PATH/" "$USERNAME@$HOST:$REMOTE_PATH"
    fi
}

ultra_scp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating ULTRA-FAST SCP...${N}\n"
    
    SSH_OPTS="-o Compression=no -c aes128-gcm@openssh.com -o MACs=umac-128@openssh.com"
    [[ -n "${SSH_KEY:-}" ]] && SSH_OPTS="$SSH_OPTS -i $SSH_KEY"
    
    if [[ "$MODE" == "upload" ]]; then
        scp -P "$PORT" $SSH_OPTS -r "$LOCAL_PATH" "$USERNAME@$HOST:$REMOTE_PATH"
    else
        scp -P "$PORT" $SSH_OPTS -r "$USERNAME@$HOST:$REMOTE_PATH" "$LOCAL_PATH"
    fi
}

ultra_ftp_transfer() {
    echo -e "${M}${BOLD}[TRANSFER] Initiating FTP transfer...${N}\n"
    
    if command -v lftp >/dev/null 2>&1; then
        LFTP_CMD="lftp -u $USERNAME -p $PORT"
        [[ "$PROTOCOL" == "ftps" ]] && LFTP_CMD="$LFTP_CMD -e 'set ftp:ssl-force true'"
        
        if [[ "$MODE" == "upload" ]]; then
            $LFTP_CMD <<EOF
open $HOST
mirror -R --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$LOCAL_PATH" "$REMOTE_PATH"
bye
EOF
        else
            $LFTP_CMD <<EOF
open $HOST
mirror --parallel=$PARALLEL_JOBS --use-pget-n=$PARALLEL_JOBS "$REMOTE_PATH" "$LOCAL_PATH"
bye
EOF
        fi
    else
        echo -e "${Y}Installing lftp for maximum FTP performance...${N}"
        sudo apt-get install -y lftp 2>/dev/null || sudo dnf install -y lftp 2>/dev/null || sudo pacman -S --noconfirm lftp
        ultra_ftp_transfer
    fi
}

# =====================================================================
#  BANDWIDTH MONITOR
# =====================================================================

monitor_bandwidth() {
    echo -e "${C}${BOLD}[MONITOR] Real-time bandwidth (Ctrl+C to stop)${N}\n"
    
    if command -v iftop >/dev/null 2>&1; then
        sudo iftop -i "$INTERFACE" -t -s 1
    elif command -v nload >/dev/null 2>&1; then
        nload "$INTERFACE"
    else
        while true; do
            if [ ! -d /sys/class/net/"$INTERFACE" ]; then
                echo "Error: Network interface '$INTERFACE' not found."
                break
            fi
            
            RX1=$(cat /sys/class/net/"$INTERFACE"/statistics/rx_bytes)
            TX1=$(cat /sys/class/net/"$INTERFACE"/statistics/tx_bytes)
            sleep 1
            RX2=$(cat /sys/class/net/"$INTERFACE"/statistics/rx_bytes)
            TX2=$(cat /sys/class/net/"$INTERFACE"/statistics/tx_bytes)
            
            RXRATE=$(( (RX2 - RX1) / 1024 / 1024 ))
            TXRATE=$(( (TX2 - TX1) / 1024 / 1024 ))
            
            echo -e "${G}↓ ${RXRATE} MB/s ${R}↑ ${TXRATE} MB/s${N}"
        done
    fi
}

# =====================================================================
#  MAIN EXECUTION
# =====================================================================

show_banner() {
    echo -e "${M}${BOLD}"
    echo "╔═══════════════════════════════════════════════════════╗"
    echo "║              UFTLN v$VERSION - by 0xbv1                   ║"
    echo "║        ULTRA-FAST TERMINAL LINK NETWORK               ║"
    echo "║       github.com/0xb0rn3/uftln                        ║"
    echo "╚═══════════════════════════════════════════════════════╝"
    echo -e "${N}\n"
}

main() {
    show_banner
    optimize_system
    detect_interfaces
    select_protocol
    setup_connection
    select_mode
    setup_paths
    
    echo -e "${M}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${M}${BOLD}║                 TRANSFER STARTING...                  ║${N}"
    echo -e "${M}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    START_TIME=$(date +%s)
    
    case $PROTOCOL in
        sftp) ultra_sftp_transfer ;;
        scp) ultra_scp_transfer ;;
        ftp|ftps) ultra_ftp_transfer ;;
    esac
    
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))
    
    echo -e "\n${G}${BOLD}╔═══════════════════════════════════════════════════════╗${N}"
    echo -e "${G}${BOLD}║              TRANSFER COMPLETE!                       ║${N}"
    echo -e "${G}${BOLD}║              Duration: ${DURATION}s                          ║${N}"
    echo -e "${G}${BOLD}╚═══════════════════════════════════════════════════════╝${N}\n"
    
    read -p "$(echo -e ${Y}Monitor bandwidth? [y/N]: ${N})" MONITOR
    [[ "$MONITOR" =~ ^[Yy]$ ]] && monitor_bandwidth
}

# Check if running as script
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
